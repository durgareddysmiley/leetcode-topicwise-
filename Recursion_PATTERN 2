🧩 SUBSET / SUBSEQUENCE (INCLUDE–EXCLUDE) RECURSION PATTERN
🧠 DEFINITION

This recursion pattern is used when each element in a collection has two independent choices:
👉 Include it or 👉 Exclude it from the current result.

It explores all possible combinations (or subsequences) of the input — forming a recursion tree of size 2ⁿ.
Common in problems like Subsets, Subsequences, Combination Sum, and Target Sum.

🕒 WHEN TO USE

Use this pattern when:

You need to generate all possible combinations or selections of elements.

The problem involves "include or exclude" type decisions for each element.

The question mentions “find all subsets”, “print all subsequences”, “all possible ways”, “combinations”, or “power set.”

💬 HOW IT USUALLY APPEARS IN QUESTIONS

You’ll often see phrases like:

“Generate all possible subsets/subsequences.”

“Find all combinations that sum up to a target.”

“Print all possible binary strings of length n.”

“Return all unique combinations of elements.”

Whenever you see such “all possible” or “every combination” wording → think INCLUDE–EXCLUDE RECURSION.

🧠 THINKING PROCESS

Whenever you see a problem like

"Find all subsets", "Print all subsequences", or "Generate all combinations",

ask yourself:

For each element — can I either take it or skip it?

Do I need all possible results (not just one)?

✅ If yes → this is an INCLUDE–EXCLUDE recursion problem.

Each element acts as a decision point with two options:

Include → move forward keeping the element.

Exclude → move forward without it.

This naturally forms a binary recursion tree → total 
2N
 outcomes.

⚙️ BASIC TEMPLATE (THINKING FORM)
def solve(idx, arr, current):
    # 1️⃣ BASE CASE
    if idx == len(arr):
        process(current)      # print, append, or evaluate
        return

    # 2️⃣ CHOICE 1 — INCLUDE arr[idx]
    current.append(arr[idx])
    solve(idx + 1, arr, current)
    current.pop()             # backtrack (undo include)

    # 3️⃣ CHOICE 2 — EXCLUDE arr[idx]
    solve(idx + 1, arr, current)

🧠 KEY THINKING STEPS
STEP	QUESTION	ACTION
1️⃣	What’s the smallest problem?	When idx == len(arr) (all elements processed)
2️⃣	What’s the decision per element?	Include or exclude
3️⃣	What’s the recursive relation?	f(i) = f(i+1 include) + f(i+1 exclude)
4️⃣	What to do with partial results?	Store, print, or count subsets
5️⃣	Is backtracking needed?	Yes — undo include before next call

🔁 VARIATIONS OF THIS PATTERN
VARIATION	DESCRIPTION	EXAMPLE PROBLEMS
SUBSETS / POWER SET	Generate all subsets of an array	Subsets (Leetcode 78)
SUBSEQUENCES OF A STRING	Include or exclude each character	Print all subsequences
COMBINATION SUM	Choose or skip numbers with repetition	Combination Sum (Leetcode 39)
TARGET SUM	Assign + or – to reach a target	Target Sum (Leetcode 494)
LETTER COMBINATIONS	Choose one letter for each digit	Letter Combinations of a Phone Number (Leetcode 17)
BINARY STRINGS	Generate all binary strings of length n	Generate Binary Strings
⏱️ COMPLEXITY
METRIC	VALUE
TIME COMPLEXITY	
O(2n)--EVERY ELENEBT HAS 2 CHOICES 
SPACE COMPLEXITY	
O(n) – recursion depth

##PROBLEM LEET CODE 78 -- 
🌟 VARIATION EXAMPLE — LEETCODE 78: SUBSETS
🧮 PROBLEM STATEMENT

Given an integer array nums of unique elements, return all possible subsets (the power set).

The solution set must not contain duplicate subsets.
Return the solution in any order.

📥 INPUT
nums = [1, 2, 3]

📤 OUTPUT
[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]

⚙️ CONSTRAINTS
1 <= nums.length <= 10
-10 <= nums[i] <= 10
All the numbers of nums are unique.

🧩 PATTERN USED
##POINT TO REMEMBER 
SUBSET / SUBSEQUENCE (INCLUDE–EXCLUDE) RECURSION PATTERN -- “For Subsets and Subsequences, we need to use Include–Exclude every time, whether it is a string or an array. No problem.” 

💡 THINKING PROCESS

For each element, we have two choices:
1️⃣ Include the element in the current subset
2️⃣ Exclude the element and move on

Continue until we process all elements.

When idx == len(nums) → we have formed one subset.

This explores all 
2 n
 subsets.

💻 SOLUTION CODE (PYTHON)
class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        c = []
        return self.main(0, nums, c, res)

    def main(self, idx, nums, c, res):
        # BASE CASE: all elements processed
        if idx >= len(nums):
            res.append(c[:])
            return

        # INCLUDE current element
        c.append(nums[idx])
        self.main(idx + 1, nums, c, res)

        # BACKTRACK (UNDO include)
        c.pop()

        # EXCLUDE current element
        self.main(idx + 1, nums, c, res)

        return res

🧠 DRY RUN EXAMPLE

Input → nums = [1, 2]

main(0, [])
├── include 1 → main(1, [1])
│     ├── include 2 → main(2, [1,2]) → store [1,2]
│     └── exclude 2 → main(2, [1])   → store [1]
└── exclude 1 → main(1, [])
      ├── include 2 → main(2, [2])   → store [2]
      └── exclude 2 → main(2, [])    → store []


✅ Output → [[], [1], [2], [1,2]]

PROCESS -- '
                               []
                 /                              \
           Take 1                              Skip 1
           [1]                                  []
        /            \                      /           \
   Take 2          Skip 2             Take 2         Skip 2
   [1,2]            [1]                [2]             []
   /    \           /   \              /   \           /   \
T3   S3        T3   S3         T3   S3        T3   S3
↓      ↓          ↓      ↓          ↓      ↓          ↓      ↓
[1,2,3] [1,2] [1,3] [1] [2,3] [2] [3] []

🪜 Start Point
idx = 0, current = [], nums = [1,2,3]


At index 0 → number = 1
Two choices:
1️⃣ Take 1 → go left
2️⃣ Skip 1 → go right

🌳 Full Recursion Story — Step by Step
🔹 LEVEL 0 (Start)
[]


➡ Take 1 → go left
current = [1]

🔹 LEVEL 1 (Take 1)
[1]


Now index = 1 → number = 2
Two choices:

Take 2 → go left

Skip 2 → go right

🟢 LEFT BRANCH (Take 2)
[1,2]


Now index = 2 → number = 3
Two choices:

Take 3 → go left

Skip 3 → go right

🔸 Left of [1,2] (Take 3)
[1,2,3]


✅ Reached end (idx = 3) → record [1,2,3]
Then return (go back to parent [1,2])

🔸 Right of [1,2] (Skip 3)

After returning, we’re back at [1,2]
Now Skip 3

[1,2]


✅ Reached end → record [1,2]
Then return again to parent [1]

🟠 RIGHT BRANCH (Skip 2)

Now we are back at [1]
We’ve finished left side (Take 2),
so now we go right side (Skip 2).

[1]


Index = 2 → number = 3
Two choices:

Take 3 → go left

Skip 3 → go right

🔸 Left of [1] (Take 3)
[1,3]


✅ Reached end → record [1,3]
Return to parent [1]

🔸 Right of [1] (Skip 3)
[1]


✅ Reached end → record [1]
Return to parent [] (root)

🔹 LEVEL 0 — RIGHT BRANCH (Skip 1)

Now we are back at root [],
left branch (Take 1) is finished,
so go right (Skip 1).

[]


Index = 1 → number = 2
Two choices:

Take 2 → go left

Skip 2 → go right

🟢 LEFT BRANCH (Take 2)
[2]


Index = 2 → number = 3
Two choices:

Take 3 → go left

Skip 3 → go right

🔸 Left of [2] (Take 3)
[2,3]


✅ Reached end → record [2,3]
Return to [2]

🔸 Right of [2] (Skip 3)
[2]


✅ Reached end → record [2]
Return to []

🟠 RIGHT BRANCH (Skip 2)

Back at root [] again.
Now we skip 2 → still [].

Index = 2 → number = 3
Two choices:

Take 3 → go left

Skip 3 → go right

🔸 Left of [] (Take 3)
[3]


✅ Reached end → record [3]
Return to []

🔸 Right of [] (Skip 3)
[]


✅ Reached end → record []
Return to main — recursion completed ✅

Problem: 90 : Subsets II

Description:
Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.

Example 1:

Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]


Example 2:

Input: nums = [0]
Output: [[],[0]]


Constraints:

1 <= nums.length <= 10

-10 <= nums[i] <= 10

Python Solution
from typing import List

class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        # Sort to handle duplicates
        b = sorted(nums)
        res = []
        cur = []
        self.dfs(0, b, cur, res)
        return res
    
    def dfs(self, idx: int, b: List[int], cur: List[int], res: List[List[int]]):
        # Base case: record current subset
        if idx == len(b):
            res.append(cur[:])
            return
        
        # TAKE current number
        cur.append(b[idx])
        self.dfs(idx + 1, b, cur, res)
        cur.pop()  # backtrack
        
        # SKIP current number and all duplicates
        next_idx = idx + 1
        while next_idx < len(b) and b[next_idx] == b[idx]:
            next_idx += 1
        self.dfs(next_idx, b, cur, res)
Let’s take nums = [1,2,2]. Sorted → b = [1,2,2].

                    []
              /               \
          Take 1               Skip 1
          [1]                   []
       /       \
   Take 2     Skip 2 (jump duplicates)
   [1,2]       [1]
  /     \
Take2   Skip2 (jump duplicates)
[1,2,2]   [1,2]

🧮 Problem: Generate Binary Strings Without Consecutive 1s

Question:

Given an integer n, return all binary strings of length n that do not contain consecutive 1s.
Return the result in lexicographically increasing order.

A binary string is a string consisting only of characters '0' and '1'.

✅ Example 1

Input:

n = 3


Output:

["000", "001", "010", "100", "101"]


Explanation:
All valid strings of length 3 without consecutive 1s are listed in order.

✅ Example 2

Input:

n = 2


Output:

["00", "01", "10"]


Explanation:
"11" is not allowed because it has consecutive 1s.

##CODE 
class Solution:
    def generateBinaryStrings(self, n):
        self.result = []
        self._helper([], n, 0)
        return self.result

    def _helper(self, current, n, idx):
        # Base case: if we reached length n, add to result
        if idx == n:
            self.result.append(''.join(current))
            return

        # If last bit is '1', we can only place '0'
        if current and current[-1] == '1':
            current.append('0')
            self._helper(current, n, idx + 1)
            current.pop()
        else:
            # Try '0' first (for lexicographic order)
            current.append('0')
            self._helper(current, n, idx + 1)
            current.pop()
            # Then try '1'
            current.append('1')
            self._helper(current, n, idx + 1)
            current.pop()
DOUBTS:
IN IF CASE  WE ONLT WRITE ABOUT 0 BUT IN ELSE CASE WE ARE TRYING BOTH '0' AND '1' BECAUSE.. IF BEFORE NUMBER IS 1 WE ONLY HAVE OPTION TO ADD ONLY '0' .. IN ELSE WE ARE 
TRYING BOTH '0' AND '1' 
2. Y WE ARE POPPING AT LAST 
ANS = BECAUSE WE ARE TRIES WITH '0' OR '1' AFTER THAT WE WANT TO REMOVE THAT AMD ADD OTHER ONE

✅ Problem: Count All Subsequences with Sum K

Difficulty: Easy
Category: Subsequence / Backtracking / Recursion

🧾 Problem Statement

Given an array nums and an integer k, return the number of non-empty subsequences of nums such that the sum of all elements in the subsequence is equal to k.

📥 Input

An array of integers nums

An integer k

📤 Output

Return the number of non-empty subsequences of nums such that their sum is equal to k.

🔍 Examples
Example 1:
Input: nums = [4, 9, 2, 5, 1], k = 10  
Output: 2  
Explanation: Subsequences with sum = 10 are [9, 1] and [4, 5, 1]

Example 2:
Input: nums = [4, 2, 10, 5, 1, 3], k = 5  
Output: 3  
Explanation: Subsequences are [4, 1], [2, 3], and [5]

##CODE 
class Solution:
    def main(self, nums, k):
        current = []
        result = []
        self.sub(current, result, nums, k, 0)
        print("All subsequences with sum", k, ":", result)
        print("Count =", len(result))
        return len(result)

    def sub(self, current, result, nums, k, idx):
        # Base case
        if idx == len(nums):
            if sum(current) == k:
                result.append(current[:])  # store a copy
            return

        # include current element
        current.append(nums[idx])
        self.sub(current, result, nums, k, idx + 1)
        current.pop()

        # exclude current element
        self.sub(current, result, nums, k, idx + 1)

