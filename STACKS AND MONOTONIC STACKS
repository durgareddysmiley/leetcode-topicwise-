üß± 1. What is a Stack?

A stack is a linear data structure that follows LIFO (Last In, First Out).
üëâ The element added last is the one removed first.

Common operations:
Operation	Description
push(x)	Add element x on top of the stack
pop()	Remove the top element
peek() or top()	See the top element without removing it
isEmpty()	Check if stack is empty

‚öôÔ∏è 2. What is a Monotonic Stack?

A monotonic stack is a special kind of stack where the elements are arranged in a monotonic (increasing or decreasing) order.

You said:
STACKS AND MONOTONIC STACKS 
ChatGPT said:
Let‚Äôs go step-by-step and make this super clear üëá

üß± 1. What is a Stack?
A stack is a linear data structure that follows LIFO (Last In, First Out).
üëâ The element added last is the one removed first.

Common operations:
Operation	Description
push(x)	Add element x on top of the stack
pop()	Remove the top element
peek() or top()	See the top element without removing it
isEmpty()	Check if stack is empty
Example (using array as stack):
Stack<Integer> st = new Stack<>();
st.push(10);
st.push(20);
st.push(30);
System.out.println(st.pop()); // Output: 30
System.out.println(st.peek()); // Output: 20
‚öôÔ∏è 2. What is a Monotonic Stack?
A monotonic stack is a special kind of stack where the elements are arranged in a monotonic (increasing or decreasing) order.
It helps solve problems like:

Next Greater Element

Previous Smaller Element

Stock Span

Trapping Rain Water

Largest Rectangle in Histogram

##UNDERSTANDING 
It‚Äôs simply a normal stack used in a specific way ‚Äî such that the elements inside follow a monotonic (ordered) property while solving certain problems.

üß† LeetCode 496 ‚Äî Next Greater Element I
üìú Problem Statement

The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.

You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.

For each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2.
If there is no next greater element, then the answer for this query is -1.

Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.

üß© Example 1

Input:

nums1 = [4,1,2]
nums2 = [1,3,4,2]


Output:

[-1, 3, -1]


Explanation:

For 4 ‚Üí there is no greater element to the right ‚Üí -1

For 1 ‚Üí next greater element is 3

For 2 ‚Üí no greater element to the right ‚Üí -1

##SOLUTION 
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        st = []
        an = []
        h = defaultdict(lambda:-1)
        for i in range(len(nums2)):
            while st and nums2[st[-1]] < nums2[i]:
                h[nums2[st[-1]]] = nums2[i]
                st.pop()
            st.append(i)
        for i in range(len(nums1)):
            if nums1[i] in h:
                an.append(h[nums1[i]])
            else:
                an.append(-1)
        return an

üîÅ LeetCode 503 ‚Äî Next Greater Element II
Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]),
return the next greater number for every element in nums.

The next greater number of an element x is the first greater number to its right,
considering the array as circular.
If it doesn‚Äôt exist, return -1 for that number.

üß© Example 1

Input:

nums = [1, 2, 1]


Output:

[2, -1, 2]


Explanation:

For the first 1, next greater is 2

For 2, there‚Äôs no greater element ‚Üí -1

For the last 1, searching circularly ‚Üí next greater is again 2
##SOLUTION 
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        st = []
        an = []
        r = 0
        res = [-1]*len(nums)
        for i in range(len(nums)*2):
            r = i % len(nums)
            while st and nums[st[-1]] < nums[r]:
                res[st.pop()] = nums[r]
            st.append(r)
        return res
# 84 Largest Rectangle in Histogram

## Problem Description
Given an array of integers `heights` representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.

### Example 1:
Input: [2,1,5,6,2,3]
Output: 10
 5 * 2 = 10

### Constraints:
- 1 <= heights.length <= 10^5  
- 0 <= heights[i] <= 10^4  

## Solution
We use a **stack-based approach** to efficiently find the largest rectangle area.

##CODE 
class Solution:
    def largestRectangleArea(self, heights):
        """
        :type heights: List[int]
        :rtype: int
        """
        heights.append(0)  # Sentinel to pop remaining bars
        st = []
        maxi = 0 

        for i in range(len(heights)):
            while st and heights[st[-1]] >= heights[i]:
                h = heights[st.pop()]
                if not st:
                    w = i
                else:
                    w = i - st[-1] - 1
                maxi = max(maxi, h * w)
            st.append(i)
        return maxi
##DOUBTS 
 if not st:
        w = i 
Here y we wrote w = i instead of w  = 1 
1Ô∏è‚É£ Case 1: Stack is empty ‚Üí w = i

When we pop a bar and the stack is empty after popping, it means:

There is no smaller bar to the left of the popped bar.

That means the rectangle can extend all the way to index 0 (the very left).

The right boundary is current index i, which is the first bar smaller than the popped bar.

So width = i - 0 = i ‚úÖ

Example:

heights = [1,1,2,2,0]

Pop index 1 (height=1) at i=2

Stack empty ‚Üí width = i = 2

Rectangle spans indices [0,1] ‚Üí width = 2

##CASE 1 
‚úÖ Width formula:

width = i


i = 1 ‚Üí width = 1? Wait, let's see carefully

Rectangle spans indices:

Popped index = 0

Current i = 1 (first smaller on right = current bar, or equal bar)

Since stack is empty ‚Üí no smaller on left ‚Üí rectangle extends to index 0

Width = i - 0 = 1?

##CASE 2 
If stack not empty ‚Üí width = i - stack[-1] - 1

Why? Because stack[-1] = last smaller on left, i = first smaller on right ‚Üí bars between them form rectangle
Y -1 : So the -1 is not arbitrary, it‚Äôs to exclude the left boundary bar. LEFT BOUNDARY COUNTS IT SELF SO WE WANT TO EXCLUDE USING -1 


        
            
        
