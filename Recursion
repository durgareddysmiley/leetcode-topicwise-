Recursion:
Recursion is a programming technique where a function calls itself to solve a problem by breaking it into smaller, simpler sub-problems, with a base case to stop the recursion.
## BASIC SUMS
1.FACTORIAL OF A NUMBER 
INPUT = 5 OUTPUT = 120
##CODE 
def factorial(n, p=1):
    if n < 1:
        return 1
    else:
        return n * factorial(n - 1)  # p is never used
print(factorial(5))  

üí° Question 2 ‚Äî Reverse an Array using Recursion
üß© Problem Statement:

Write a Python program to reverse an array using recursion.
Do not use loops or built-in reverse functions.

üî¢ Input:
N = 5
arr = [10, 20, 30, 40, 50]

üéØ Output:
Reversed array: [50, 40, 30, 20, 10]

üß† Approach:

Use two pointers ‚Äî start and end.

Swap elements at these positions.

Move start forward and end backward recursively until they meet.

üíª Code (Python):
def reverse_array(arr, start, end):
    if start >= end:          # Base case
        return
    arr[start], arr[end] = arr[end], arr[start]
    reverse_array(arr, start + 1, end - 1)

# Main
N = 5
arr = [10, 20, 30, 40, 50]
reverse_array(arr, 0, N - 1)
print("Reversed array:", arr)

## PRPOBLEM 3 -- SUM OF N NUBMBERS 
üî¢ Input:
N = 5
üéØ Output:
Sum = 15
##CODE 
def first(i, N):
    if i > N:
        return 0  # base case: if i > N, sum is 0
    else:
        return i + first(i + 1, N)  # add current i and sum of next numbers
N = int(input("Enter N: "))
print(first(1, N)) -

‚ö° Pattern 1:
Exponentiation by Squaring (Divide and Conquer Pattern)

üß† Definition:

Exponentiation by Squaring is a recursive divide and conquer technique used to calculate powers efficiently.
It reduces the time complexity from O(n) to O(log n) by dividing the exponent by 2 in each step.

‚öôÔ∏è Working:

Base Case:
If n == 0, return 1.

Recursive Step:

Compute half = power(x, n // 2)

If n is even ‚Üí result = half * half

If n is odd ‚Üí result = half * half * x

Used In:

Pow(x, n)

Count Good Numbers

üíª Example (Python):
def power(x, n):
    if n == 0:
        return 1
    half = power(x, n // 2)
    if n % 2 == 0:
        return half * half
    else:
        return half * half * x 

‚è±Ô∏è Complexity:

Time: O(log n)

Space: O(log n) (due to recursion stack)

.

üí° LeetCode 50 ‚Äî Pow(x, n)
üß© Problem Statement:

Implement pow(x, n), which calculates x raised to the power n (i.e., x‚Åø).

üî¢ Examples:

Example 1:

Input: x = 2.00000, n = 10
Output: 1024.00000


Example 2:

Input: x = 2.10000, n = 3
Output: 9.26100


Example 3:

Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2^-2 = 1/2^2 = 1/4 = 0.25

‚öôÔ∏è Constraints:

-100.0 < x < 100.0

-2¬≥¬π ‚â§ n ‚â§ 2¬≥¬π - 1

n is an integer

Either x is not zero or n > 0

-10‚Å¥ ‚â§ x‚Åø ‚â§ 10‚Å¥

üß† Approach:

Use recursion + divide and conquer (Exponentiation by Squaring).

Handle negative powers by converting x to 1/x and n to -n.

Recursively compute the half power and multiply accordingly.

üíª Code (Python):
class Solution(object):
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        """
        if n < 0:
            x = 1 / x
            n = -n
        return self.power(x, n)
    
    def power(self, x, n):
        if n == 0:
            return 1
        half = self.power(x, n // 2)
        if n % 2 == 0:
            return half * half
        else:
            return half * half * x
##DOUBTS 
if n % 2 == 0:
    return half * half
else:
    return half * half * x
Y WE ARE MULTIPLYING X WHEN N IS ODD:
Example:

ùë•
5
=
ùë•
√ó
ùë•
√ó
ùë•
√ó
ùë•
√ó
ùë•
x
5
=x√óx√óx√óx√óx

So there are 5 x‚Äôs multiplied together.

üí° Step 2: Dividing n by 2

When we use n // 2,
we are cutting n into two equal halves ‚Äî but only full halves, no decimals.

Now, if n is odd, like 5:

5 // 2 = 2

So we can only make 2 full pairs of x¬≤ ‚Äî
but one x is left over because 5 is not evenly divisible by 2.
SO WE ARE MULTIPLYING WITH X 
üí° LeetCode 1922 ‚Äî Count Good Numbers
üß© Problem Statement:

A digit string is good if:

Digits at even indices are even (0, 2, 4, 6, 8).

Digits at odd indices are prime (2, 3, 5, 7).

Given an integer n, return the total number of good digit strings of length n.
Since the answer may be very large, return it modulo (10‚Åπ + 7).

üî¢ Examples:

Example 1:

Input: n = 1
Output: 5
Explanation: The good numbers of length 1 are "0", "2", "4", "6", "8".


Example 2:

Input: n = 4
Output: 400


Example 3:

Input: n = 50
Output: 564908303

‚öôÔ∏è Constraints:

1 ‚â§ n ‚â§ 10¬π‚Åµ

üß† Approach:

Total digits at even indices ‚Üí ei = (n + 1) // 2

Each even index can be filled in 5 ways (0, 2, 4, 6, 8).

Total digits at odd indices ‚Üí oi = n // 2

Each odd index can be filled in 4 ways (2, 3, 5, 7).

Use Exponentiation by Squaring to compute powers efficiently in O(log n) time.

üíª CODE (Python):
class Solution(object):
    def countGoodNumbers(self, n):
        """
        :type n: int
        :rtype: int
        """
        mod = 10**9 + 7

        def power(a, n):
            if n == 0:
                return 1
            half = power(a, n // 2)
            if n % 2 == 0:
                return (half * half) % mod
            else:
                return (half * half * a) % mod

        ei = (n + 1) // 2  # even indices count
        oi = n // 2        # odd indices count

        return (power(5, ei) * power(4, oi)) % mod

##PROCESS 
Example: power(2, 5)

power(2, 5) calls power(2, 2)

power(2, 2) calls power(2, 1)

power(2, 1) calls power(2, 0)

power(2, 0) returns 1 (base case)

power(2, 1) uses half=1 ‚Üí returns 
1‚àó1‚àó2=2
power(2, 2) uses half=2 ‚Üí returns 
2‚àó2=4
power(2, 5) uses half=4 ‚Üí returns 
4‚àó4‚àó2=32
Result: 
2 POWER 5 IS EQUAL 32
‚è±Ô∏è Complexity:

Time: O(log n)

Space: O(log n) (due to recursion)


üí° Question ‚Äî Sort a Stack using Recursion
üß© Problem Statement:

Given a stack of integers, sort it in descending order using recursion only.

The top of the stack should contain the greatest element.

You may not use loops or built-in sorting.

You can only use standard stack operations: push, pop, peek, and isEmpty. 

üî¢ Examples:

Example 1:

Input: stack = [4, 1, 3, 2]
Output: [4, 3, 2, 1]
Explanation: Largest element (4) is at the top, smallest (1) at the bottom.

üß† Approach:

Recursively pop the top element until the stack is empty.

Insert each element back into the stack in sorted order using a recursive helper.

Compare the popped element with the top of the stack to decide its position.

##CODE 
EMPTY WANT TO WRITE

üí° Question ‚Äî Reverse a Stack using Recursion
üß© Problem Statement:

Given a stack of integers, reverse the stack using recursion only.

You cannot use loops or extra data structures (arrays, queues, etc.).

Only standard stack operations are allowed: push, pop, peek/top, isEmpty.

The reversal must modify the stack in-place.

üî¢ Examples:

Example 1:

Input: stack = [4, 1, 3, 2]
Output: [2, 3, 1, 4]

üß† Approach:

Recursively pop the top element until the stack is empty.

Insert each element at the bottom of the stack recursively.

This reverses the order without using loops or extra storage.

üíª CODE (Python):
def sortStack(stack):
    if len(stack) <= 1:
        return
    top = stack.pop()
    sortStack(stack)
    insertInSortedOrder(stack, top)
def insertInSortedOrder(stack, element):
    if not stack or element >= stack[-1]:
        stack.append(element)
        return
    top = stack.pop()
    insertInSortedOrder(stack, element)
    stack.append(top)

##MY DOUBTS 
top = stack.pop() # top = 5, 
stack becomes [] 
insertInSortedOrder(stack, 4) # recursive call with stack = [] 
stack.append(top) 
here i have one doubt if it goes to insertInSortedOrder(stack, 4) then it goes to above function but how it go stack.append(top)
##ANSWER 
Let's visualize the exact control flow (with indentation showing the "depth"):
Starting with:
insertInSortedOrder([5], 4)

1Ô∏è‚É£ First call: insertInSortedOrder([5], 4)
top = stack.pop()           # top = 5, stack becomes []
insertInSortedOrder([], 4)  # calls itself
# It now **waits here**, suspended, until that recursive call finishes

2Ô∏è‚É£ Second call: insertInSortedOrder([], 4)
stack.append(4)             # stack is now [4]
return                      # returns to where it was called from

üîô Back to 1Ô∏è‚É£ First call (now resumes):
# After recursive call is done, we continue
stack.append(top)           # top = 5 ‚Üí stack becomes [4, 5]

‚è±Ô∏è Complexity:

Time: O(N¬≤) ‚Äî for each element, recursive insertion at the bottom

Space: O(N) ‚Äî recursion stack
