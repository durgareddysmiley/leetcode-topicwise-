Recursion:
Recursion is a programming technique where a function calls itself to solve a problem by breaking it into smaller, simpler sub-problems, with a base case to stop the recursion.
## BASIC SUMS
1.FACTORIAL OF A NUMBER 
INPUT = 5 OUTPUT = 120
##CODE 
def factorial(n, p=1):
    if n < 1:
        return 1
    else:
        return n * factorial(n - 1)  # p is never used
print(factorial(5))  

üí° Question 2 ‚Äî Reverse an Array using Recursion
üß© Problem Statement:

Write a Python program to reverse an array using recursion.
Do not use loops or built-in reverse functions.

üî¢ Input:
N = 5
arr = [10, 20, 30, 40, 50]

üéØ Output:
Reversed array: [50, 40, 30, 20, 10]

üß† Approach:

Use two pointers ‚Äî start and end.

Swap elements at these positions.

Move start forward and end backward recursively until they meet.

üíª Code (Python):
def reverse_array(arr, start, end):
    if start >= end:          # Base case
        return
    arr[start], arr[end] = arr[end], arr[start]
    reverse_array(arr, start + 1, end - 1)

# Main
N = 5
arr = [10, 20, 30, 40, 50]
reverse_array(arr, 0, N - 1)
print("Reversed array:", arr)

## PRPOBLEM 3 -- SUM OF N NUBMBERS 
üî¢ Input:
N = 5
üéØ Output:
Sum = 15
##CODE 
def first(i, N):
    if i > N:
        return 0  # base case: if i > N, sum is 0
    else:
        return i + first(i + 1, N)  # add current i and sum of next numbers
N = int(input("Enter N: "))
print(first(1, N)) -
GENERAL PATTERN 1 TEMPLATE:
1. Generic Divide & Conquer Pattern

Template:

if (base case) return value
left = solve(left half)
right = solve(right half)
return combine(left, right)


Key points:

Divide: Break the problem into 2 or more independent subproblems (left half, right half).

Conquer: Solve each subproblem recursively.

Combine: Merge the results of subproblems to get the final answer.

Examples: Merge Sort, Max/Min in array, Binary Search Tree operations.

üß© Variations of Divide & Conquer Templates
Type	Example Problem	Code Template	Observation
Classic Two-Recursion	Merge Sort, Max in Array	left = solve(left half)
right = solve(right half)
return combine(left, right)	Two independent subproblems
Single-Recursion (Reduced Input)	Exponentiation by Squaring, Sort Stack	solve(smaller input)
combine result	Only one smaller subproblem
In-place Divide & Conquer	Quick Sort	Split array around pivot, then recurse left and right	Divide happens through indices, not copies
Implicit Divide & Conquer	Binary Search	if condition: return solve(left) else return solve(right)	Only one recursive path taken at a time

WHICH IS DOWN THAT IS SAME PATTERN BUT SLIGHTLY DIFFERENT 

BOTH PATTERN 1 ARE SAME  Both use Divide & Conquer ‚Äî you reduce a problem into smaller subproblems and combine results.
‚ö° Pattern 1:
Exponentiation by Squaring (Divide and Conquer Pattern)

üß† Definition:

Exponentiation by Squaring is a recursive divide and conquer technique used to calculate powers efficiently.
It reduces the time complexity from O(n) to O(log n) by dividing the exponent by 2 in each step.

‚öôÔ∏è Working:

Base Case:
If n == 0, return 1.

Recursive Step:

Compute half = power(x, n // 2)

If n is even ‚Üí result = half * half

If n is odd ‚Üí result = half * half * x

Used In:

Pow(x, n)

Count Good Numbers

üíª Example (Python):
def power(x, n):
    if n == 0:
        return 1
    half = power(x, n // 2)
    if n % 2 == 0:
        return half * half
    else:
        return half * half * x 

‚è±Ô∏è Complexity:

Time: O(log n)

Space: O(log n) (due to recursion stack)

.

üí° LeetCode 50 ‚Äî Pow(x, n)
üß© Problem Statement:

Implement pow(x, n), which calculates x raised to the power n (i.e., x‚Åø).

üî¢ Examples:

Example 1:

Input: x = 2.00000, n = 10
Output: 1024.00000


Example 2:

Input: x = 2.10000, n = 3
Output: 9.26100


Example 3:

Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2^-2 = 1/2^2 = 1/4 = 0.25

‚öôÔ∏è Constraints:

-100.0 < x < 100.0

-2¬≥¬π ‚â§ n ‚â§ 2¬≥¬π - 1

n is an integer

Either x is not zero or n > 0

-10‚Å¥ ‚â§ x‚Åø ‚â§ 10‚Å¥

üß† Approach:

Use recursion + divide and conquer (Exponentiation by Squaring).

Handle negative powers by converting x to 1/x and n to -n.

Recursively compute the half power and multiply accordingly.

üíª Code (Python):
class Solution(object):
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        """
        if n < 0:
            x = 1 / x
            n = -n
        return self.power(x, n)
    
    def power(self, x, n):
        if n == 0:
            return 1
        half = self.power(x, n // 2)
        if n % 2 == 0:
            return half * half
        else:
            return half * half * x
##DOUBTS 
if n % 2 == 0:
    return half * half
else:
    return half * half * x
Y WE ARE MULTIPLYING X WHEN N IS ODD:
Example:

X POWER 5 = X X X X X 

So there are 5 x‚Äôs multiplied together.

üí° Step 2: Dividing n by 2

When we use n // 2,
we are cutting n into two equal halves ‚Äî but only full halves, no decimals.

Now, if n is odd, like 5:

5 // 2 = 2

So we can only make 2 full pairs of x¬≤ ‚Äî
but one x is left over because 5 is not evenly divisible by 2.
SO WE ARE MULTIPLYING WITH X 
üí° LeetCode 1922 ‚Äî Count Good Numbers
üß© Problem Statement:

A digit string is good if:

Digits at even indices are even (0, 2, 4, 6, 8).

Digits at odd indices are prime (2, 3, 5, 7).

Given an integer n, return the total number of good digit strings of length n.
Since the answer may be very large, return it modulo (10‚Åπ + 7).

üî¢ Examples:

Example 1:

Input: n = 1
Output: 5
Explanation: The good numbers of length 1 are "0", "2", "4", "6", "8".


Example 2:

Input: n = 4
Output: 400


Example 3:

Input: n = 50
Output: 564908303

‚öôÔ∏è Constraints:

1 ‚â§ n ‚â§ 10¬π‚Åµ

üß† Approach:

Total digits at even indices ‚Üí ei = (n + 1) // 2

Each even index can be filled in 5 ways (0, 2, 4, 6, 8).

Total digits at odd indices ‚Üí oi = n // 2

Each odd index can be filled in 4 ways (2, 3, 5, 7).

Use Exponentiation by Squaring to compute powers efficiently in O(log n) time.

üíª CODE (Python):
class Solution(object):
    def countGoodNumbers(self, n):
        """
        :type n: int
        :rtype: int
        """
        mod = 10**9 + 7

        def power(a, n):
            if n == 0:
                return 1
            half = power(a, n // 2)
            if n % 2 == 0:
                return (half * half) % mod
            else:
                return (half * half * a) % mod

        ei = (n + 1) // 2  # even indices count
        oi = n // 2        # odd indices count

        return (power(5, ei) * power(4, oi)) % mod

##PROCESS 
Example: power(2, 5)

power(2, 5) calls power(2, 2)

power(2, 2) calls power(2, 1)

power(2, 1) calls power(2, 0)

power(2, 0) returns 1 (base case)

power(2, 1) uses half=1 ‚Üí returns 
1‚àó1‚àó2=2
power(2, 2) uses half=2 ‚Üí returns 
2‚àó2=4
power(2, 5) uses half=4 ‚Üí returns 
4‚àó4‚àó2=32
Result: 
2 POWER 5 IS EQUAL 32
‚è±Ô∏è Complexity:

Time: O(log n)

Space: O(log n) (due to recursion)


üí° Question ‚Äî Sort a Stack using Recursion
üß© Problem Statement:

Given a stack of integers, sort it in descending order using recursion only.

The top of the stack should contain the greatest element.

You may not use loops or built-in sorting.

You can only use standard stack operations: push, pop, peek, and isEmpty. 

üî¢ Examples:

Example 1:

Input: stack = [4, 1, 3, 2]
Output: [4, 3, 2, 1]
Explanation: Largest element (4) is at the top, smallest (1) at the bottom.

üß† Approach:

Recursively pop the top element until the stack is empty.

Insert each element back into the stack in sorted order using a recursive helper.

Compare the popped element with the top of the stack to decide its position.

##CODE 
def sortStack(stack):
    if len(stack) <= 1:
        return
    top = stack.pop()
    sortStack(stack)
    insertInSortedOrder(stack, top)
def insertInSortedOrder(stack, element):
    if not stack or element >= stack[-1]:
        stack.append(element)
        return
    top = stack.pop()
    insertInSortedOrder(stack, element)
    stack.append(top)

##MY DOUBTS 
top = stack.pop() # top = 5, 
stack becomes [] 
insertInSortedOrder(stack, 4) # recursive call with stack = [] 
stack.append(top) 
here i have one doubt if it goes to insertInSortedOrder(stack, 4) then it goes to above function but how it go stack.append(top)
##ANSWER 
Let's visualize the exact control flow (with indentation showing the "depth"):
Starting with:
insertInSortedOrder([5], 4)

1Ô∏è‚É£ First call: insertInSortedOrder([5], 4)
top = stack.pop()           # top = 5, stack becomes []
insertInSortedOrder([], 4)  # calls itself
# It now **waits here**, suspended, until that recursive call finishes

2Ô∏è‚É£ Second call: insertInSortedOrder([], 4)
stack.append(4)             # stack is now [4]
return                      # returns to where it was called from

üîô Back to 1Ô∏è‚É£ First call (now resumes):
# After recursive call is done, we continue
stack.append(top)           # top = 5 ‚Üí stack becomes [4, 5]

##MORE DETAIL IF 4,5 ARE THERE..NOW 3 IS THERE WE WANT TO REMOVE 4, 5  AND ADD 3 THEN ADD 4 , 5 

Starting situation:

We have a stack: [4, 5] (top is rightmost ‚Üí 5)

We want to insert the element 3 in sorted order into this stack.

Step 1: insertInSortedOrder([4,5], 3) starts

Current stack: [4, 5]

Element to insert: 3

Check condition: Is stack empty or 3 >= 5? No, because 3 < 5.

So we pop the top element:

top = stack.pop()  # top = 5


Now the stack is:

stack = [4]


We pause this function here and call recursively:

insertInSortedOrder([4], 3)

Step 2: insertInSortedOrder([4], 3) starts (recursive call)

Current stack: [4]

Element to insert: 3

Check condition: Is stack empty or 3 >= 4? No, because 3 < 4.

So we pop the top element again:

top = stack.pop()  # top = 4


Now the stack is empty:

stack = []


We pause this function here and call recursively:

insertInSortedOrder([], 3)

Step 3: insertInSortedOrder([], 3) starts (next recursive call)

Current stack: [] (empty)

Element to insert: 3

Check condition: Is stack empty? Yes!

So we directly append 3:

stack.append(3)


Now the stack is:

stack = [3]


This call returns back to the previous recursive call (insertInSortedOrder([4], 3)).

Step 4: Back to insertInSortedOrder([4], 3)

The recursive call we made returned and the stack is now:

stack = [3]


Now we append the saved top back to the stack:

stack.append(top)  # top = 4


So the stack becomes:

stack = [3, 4]


This call returns back to the original call (insertInSortedOrder([4,5], 3)).

Step 5: Back to insertInSortedOrder([4,5], 3)

The recursive call we made returned and the stack is now:

stack = [3, 4]


Now we append the saved top back to the stack:

stack.append(top)  # top = 5


So the stack becomes:

stack = [3, 4, 5]


This call finishes, and the element 3 has been inserted in the correct sorted position.

Summary:

We temporarily removed 5 and saved it in top.

Then we temporarily removed 4 and saved it in top.

We hit the empty stack and inserted 3.

Then, on returning from recursion, we put 4 back on top of 3.

Finally, we put 5 back on top of 4.

The stack becomes fully sorted with the new element inserted.

‚è±Ô∏è Complexity:

Time: O(N¬≤) ‚Äî for each element, recursive insertion at the bottom

Space: O(N) ‚Äî recursion stack


## Question LEET CODE 53 : Maximum Subarray

Problem:
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum, and return its sum.

Example 1

Input:

nums = [-2,1,-3,4,-1,2,1,-5,4]


Output:

6


Explanation:
The subarray [4,-1,2,1] has the largest sum 6.

##CODE 
from typing import List

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # Call the divide and conquer helper function
        return self.sub(nums, 0, len(nums)-1)
    
    def sub(self, nums, l, h):
        # Base case: only one element
        if l == h:
            return nums[l]
        
        mid = (l + h) // 2
        
        # Maximum subarray sum in left half
        left_max = self.sub(nums, l, mid)
        
        # Maximum subarray sum in right half
        right_max = self.sub(nums, mid+1, h)
        
        # Maximum subarray sum crossing the middle
        cross_max = self.cross_sum(nums, l, mid, h)
        
        # Return the maximum of the three
        return max(left_max, right_max, cross_max)
    
    def cross_sum(self, nums, l, mid, h):
        # Maximum sum starting from mid and going left
        left_sum = float('-inf')
        current_sum = 0
        for i in range(mid, l-1, -1):
            current_sum += nums[i]
            left_sum = max(left_sum, current_sum)
        
        # Maximum sum starting from mid+1 and going right
        right_sum = float('-inf')
        current_sum = 0
        for i in range(mid+1, h+1):
            current_sum += nums[i]
            right_sum = max(right_sum, current_sum)
        
        # Return sum of left and right maximums crossing mid
        return left_sum + right_sum
##DOUBTS 
IN THIS SUM PATTERN SAME BUT SLIGHTLY DIFFERENT OF EACH RECURSION STORING HERE 
## MY DOUBT Y WE ARE CHECKING      return max(left_max, right_max, cross_max) left_max and right_max y checking what if i check only cross max
Answer : it will satisfy only some inputs not all..
Ex = 10,-2,-3,-4 is there max = 10 but if check only cross we get another minimum value not 10 so by string left_max and right_max we can get that because 
first left is 10 it is maximum and it doesnt change so 10 come..Dont confuse between left_sum and left_max..Left sum changes left_max is storing 10 

##WANT TO REMEMBER IF WE WRITING  return self.mergeKLists(lists[i],lists[i+1]) WE ARE CONFUSING IN CODE SO THAT TRY A VARIABLE LIKE 
 l1 = lists[i]
                l2 = lists[i+1] if i < len(lists)-1 else None 
                m.append(self.process(l1,l2))
LeetCode 23: Merge k Sorted Lists

Problem Statement:
You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.

Task: Merge all the linked-lists into one sorted linked-list and return it.

Example 1:

Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation:
The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
Merging them into one sorted linked list:
1->1->2->3->4->4->5->6
##CODE 
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution(object):
    def process(self,l1,l2):
        a = ListNode(0)
        b = a  
        while l1 and l2:
            if l1.val >= l2.val:
                b.next = ListNode(l2.val)
                b  = b.next
                l2 = l2.next
            else:
                b.next = ListNode(l1.val)
                b= b.next
                l1 = l1.next 
        if l1 :
            b.next = l1
        if l2:
            b.next = l2
        return a.next 

    def mergeKLists(self, lists):
        """
        :type lists: List[Optional[ListNode]]
        :rtype: Optional[ListNode]
        """
        if len(lists) < 1:
            return None
        while len(lists) > 1:
            m = []
            for i in range(0,len(lists),2):
                l1 = lists[i]
                l2 = lists[i+1] if i < len(lists)-1 else None 
                m.append(self.process(l1,l2))
            lists  =  m
        return lists[0]
##DOUBT 
INSTEAD OF   m.append(self.process(l1,l2)) RETURN M Y WE ARE DOING  lists  =  m
        return lists[0]
Excellent question again üëè ‚Äî you‚Äôre understanding the logic very deeply now. Let‚Äôs clear this confusion completely with a step-by-step explanation.

üß† The doubt:

You asked:

Instead of

m.append(self.process(l1, l2))
lists = m
return lists[0]


why not just

return m


or something like that.

üí° The key idea

The function mergeKLists merges K sorted linked lists ‚Äî not just two.

So it must keep merging lists until only one list remains.

That‚Äôs why we write:

lists = m


‚Äîto update lists after each round of merging.

Let‚Äôs see it step-by-step.

üîÅ What happens in the loop

Imagine you start with:

lists = [L1, L2, L3, L4]


Each iteration of the while loop merges pairs of lists using:

m.append(self.process(l1, l2))


After one full loop:

m = [Merged(L1, L2), Merged(L3, L4)]


Now m contains 2 merged lists.

If you return m now ‚Äî ‚ùå wrong!
You‚Äôre returning a list of 2 linked lists, not one single merged list.

We want to continue merging until there‚Äôs only one list left, like this:

lists = [Merged(L1, L2), Merged(L3, L4)]  # assign m to lists


Now, in the next iteration, we again merge these 2 lists.

üîö When does it stop?
while len(lists) > 1:


The loop continues until len(lists) == 1.

At that point, we have:

lists = [FinalMergedList]


So finally, we return:

return lists[0]


‚úÖ which is the single final merged linked list.

üß© In simple words:
Step	Variable	What it stores
Start	lists	all original k lists
After one loop	m	newly merged pairs
Then	lists = m	update for next round
Loop continues	until only one list left	
End	lists[0]	final merged linked list
‚úÖ Final answer:

We do

lists = m
return lists[0]


because we need to keep merging in rounds until only one list remains.
If we return m early, we‚Äôd get a list of lists, not the final merged list.

Would you like me to show this with a small dry-run diagram (like round 1 ‚Üí round 2 ‚Üí final list)?
It‚Äôll make this concept crystal clear visually.

