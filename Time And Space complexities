TIME AND SPACE COMPLEXITIES
WHAT IS TIME COMPLEXITY?

Time complexity tells how the running time of an algorithm grows as the input size increases.
It does not measure seconds, it measures number of operations.

We represent it using Big-O notation.

WHAT IS SPACE COMPLEXITY?

Space complexity tells how much extra memory an algorithm uses apart from input data.

BIG-O NOTATION
Big-O describes the worst-case growth of an algorithm when input size becomes large.
O(1) – CONSTANT TIME

MEANING
Time does not change with input size.

EXAMPLE
x = arr[0]

NOTES

No loops
Fastest possible
O(n) – LINEAR TIME

MEANING

Time grows proportionally with input size.

EXAMPLE

for i in range(n):
    print(arr[i])

NOTES

One loop
n elements → n operations
O(n²) – QUADRATIC TIME

MEANING

Time grows very fast because of nested loops.

EXAMPLE

for i in range(n):
    for j in range(n):
        print(i, j)

NOTES

Two loops with same variable
n × n operations
Slow for large input

O(log n) – LOGARITHMIC TIME
MEANING

Input size is reduced by half each step.

EXAMPLE

Binary Search

while low <= high:
    mid = (low + high) // 2

NOTES

Very fast
Used in searching

O(n log n) – LINEARITHMIC TIME

MEANING

For each element, a log n operation is done.

EXAMPLE

Merge Sort
Quick Sort (average case)

Ex:
The "Log n" Part (Dividing)In algorithms like Merge Sort, the first thing we do is split the pile in half, then split those halves again, 
until we have individual 8 books -> 4 books -> 2 books  -> 1book
How many times did we split? 3 times.
In math, log_2(8) = 3 This "splitting" or "searching" depth is the log n part.

NOTES

Faster than O(n²)
Slower than O(n)

O(m × n) – MATRIX TIME COMPLEXITY

MEANING

Two different input sizes are involved.

EXAMPLE

for i in range(m):
    for j in range(n):
        print(mat[i][j])

NOTES

Used for matrices
m = rows, n = columns

DIFFERENCE BETWEEN O(n²) AND O(m × n)

O(n²)
Both loops depen on same variable
Used when sizes are equal

O(m × n)

Loops depend on different variables
Used for rectangular matrices

SPACE COMPLEXITY EXAMPLES

O(1) SPACE

EXAMPLE
count = 0

NOTES

Only variables
Constant memory
O(n) SPACE

EXAMPLE
arr = [0] * n

NOTES

Extra array of size n
O(n²) SPACE

EXAMPLE

matrix = [[0]*n for _ in range(n)]

NOTES

Extra 2D matrix

IMPORTANT INTERVIEW RULES

Count loops to find time complexity
Count extra data structures to find space complexity
Ignore constants and small terms
Always consider worst case

ONE-LINE MEMORY TRICKS

One loop → O(n)
Nested loop → O(n²)
Halving input → O(log n)
Matrix → O(m × n)

FINAL THUMB RULE

Time = how many times code runs
Space = how much extra memory is used

##SPACE COMPLEXITY 
1. CONSTANT SPACE O(1) – Dry Run
def sum_array(arr):
    total = 0
    for x in arr:
        total += x
    return total

Input example:
arr = [2, 4, 6]

Step-by-step execution
Step	Operation	total value	Memory explanation
1	Initialize total	0	One variable created → O(1)
2	x = 2 (first loop)	total = 0 + 2 = 2	No new memory created, just update existing total
3	x = 4 (second loop)	total = 2 + 4 = 6	Same total variable updated, memory still constant
4	x = 6 (third loop)	total = 6 + 6 = 12	Still the same variable, no extra memory per element
5	Return total	12	Only one variable exists → O(1)
Why space is O(1)

total does not multiply with array size.

Whether arr has 3 elements or 3 million, memory used by total = 1 variable.

The loop variable x is temporary and overwrites itself each iteration.

No extra arrays or recursion are used.

✅ Maximum memory never grows with n → O(1)

2. Linear Space O(n) – Dry Run
def double_array(arr):
    new_arr = []
    for x in arr:
        new_arr.append(x * 2)
    return new_arr

Input example:
arr = [2, 4, 6]

Step-by-step execution
Step	Operation	new_arr value	Memory explanation
1	Initialize new_arr	[]	Empty array created → memory proportional to 0 now
2	x = 2 (first loop)	[4]	Added 1 element → extra memory grows with input
3	x = 4 (second loop)	[4, 8]	Added another element → memory grows linearly
4	x = 6 (third loop)	[4, 8, 12]	Added another element → memory still grows with n
5	Return new_arr	[4, 8, 12]	Array contains 3 elements → memory = 3 elements
Why space is O(n)

new_arr grows as input grows

If arr has 3 elements → new_arr has 3 elements

If arr has 1,000 elements → new_arr has 1,000 elements

Memory is proportional to n

Each element in new_arr takes space → total memory = n units

Loop variable x is temporary
 
Overwrites itself each iteration → does not add extra space

No recursion used

Only the array contributes to memory growth

✅ Maximum memory grows linearly with input → O(n)

3. Recursive O(n)
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n-1)


Input example: n = 3

Step	Operation	Stack content	Memory explanation
1	factorial(3) called	factorial(3) waiting	1 stack frame
2	factorial(2) called	factorial(3), factorial(2) waiting	2 stack frames
3	factorial(1) called	factorial(3), factorial(2), factorial(1) waiting	3 stack frames
4	factorial(0) called	factorial(3), factorial(2), factorial(1), factorial(0) waiting	4 stack frames
5	factorial(0) returns 1	start returning	stack frames removed one by one

✅ Why O(n): Each recursive call adds a stack frame; max depth = n → memory grows linearly.
THIS IS 0(N) BECAUSE factorial(3) , factorial(2),factorial(1) these are new boxes creating every time how many times n there  they want to create   

7. Nested loops O(1)  ##REMEMBER MORE LOOPS != MORE SPACE 
def count_pairs(n):
    count = 0
    for i in range(n):
        for j in range(n):
            count += 1
    return count


Input example: n = 3

Step	Operation	Variables	Memory explanation
Loop	All iterations	count variable	Only 1 variable used; loops do not create extra memory

✅ Why O(1): Loops affect time, not space; only count exists. 


