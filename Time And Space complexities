TIME AND SPACE COMPLEXITIES
WHAT IS TIME COMPLEXITY?

Time complexity tells how the running time of an algorithm grows as the input size increases.
It does not measure seconds, it measures number of operations.

We represent it using Big-O notation.

WHAT IS SPACE COMPLEXITY?

Space complexity tells how much extra memory an algorithm uses apart from input data.

BIG-O NOTATION
Big-O describes the worst-case growth of an algorithm when input size becomes large.
O(1) – CONSTANT TIME

MEANING
Time does not change with input size.

EXAMPLE
x = arr[0]

NOTES

No loops
Fastest possible
O(n) – LINEAR TIME

MEANING

Time grows proportionally with input size.

EXAMPLE

for i in range(n):
    print(arr[i])

NOTES

One loop
n elements → n operations
O(n²) – QUADRATIC TIME

MEANING

Time grows very fast because of nested loops.

EXAMPLE

for i in range(n):
    for j in range(n):
        print(i, j)

NOTES

Two loops with same variable
n × n operations
Slow for large input

O(log n) – LOGARITHMIC TIME
MEANING

Input size is reduced by half each step.

EXAMPLE

Binary Search

while low <= high:
    mid = (low + high) // 2

NOTES

Very fast
Used in searching

O(n log n) – LINEARITHMIC TIME

MEANING

For each element, a log n operation is done.

EXAMPLE

Merge Sort
Quick Sort (average case)

Ex:
The "Log n" Part (Dividing)In algorithms like Merge Sort, the first thing we do is split the pile in half, then split those halves again, 
until we have individual 8 books -> 4 books -> 2 books  -> 1book
How many times did we split? 3 times.
In math, log_2(8) = 3 This "splitting" or "searching" depth is the log n part.

NOTES

Faster than O(n²)
Slower than O(n)

O(m × n) – MATRIX TIME COMPLEXITY

MEANING

Two different input sizes are involved.

EXAMPLE

for i in range(m):
    for j in range(n):
        print(mat[i][j])

NOTES

Used for matrices
m = rows, n = columns

DIFFERENCE BETWEEN O(n²) AND O(m × n)

O(n²)
Both loops depen on same variable
Used when sizes are equal

O(m × n)

Loops depend on different variables
Used for rectangular matrices

SPACE COMPLEXITY EXAMPLES

O(1) SPACE

EXAMPLE
count = 0

NOTES

Only variables
Constant memory
O(n) SPACE

EXAMPLE
arr = [0] * n

NOTES

Extra array of size n
O(n²) SPACE

EXAMPLE

matrix = [[0]*n for _ in range(n)]

NOTES

Extra 2D matrix

IMPORTANT INTERVIEW RULES

Count loops to find time complexity
Count extra data structures to find space complexity
Ignore constants and small terms
Always consider worst case

ONE-LINE MEMORY TRICKS

One loop → O(n)
Nested loop → O(n²)
Halving input → O(log n)
Matrix → O(m × n)

FINAL THUMB RULE

Time = how many times code runs
Space = how much extra memory is used

##SPACE COMPLEXITY 
1. CONSTANT SPACE O(1) – Dry Run
def sum_array(arr):
    total = 0
    for x in arr:
        total += x
    return total

Input example:
arr = [2, 4, 6]

Step-by-step execution
Step	Operation	total value	Memory explanation
1	Initialize total	0	One variable created → O(1)
2	x = 2 (first loop)	total = 0 + 2 = 2	No new memory created, just update existing total
3	x = 4 (second loop)	total = 2 + 4 = 6	Same total variable updated, memory still constant
4	x = 6 (third loop)	total = 6 + 6 = 12	Still the same variable, no extra memory per element
5	Return total	12	Only one variable exists → O(1)
Why space is O(1)

total does not multiply with array size.

Whether arr has 3 elements or 3 million, memory used by total = 1 variable.

The loop variable x is temporary and overwrites itself each iteration.

No extra arrays or recursion are used.

✅ Maximum memory never grows with n → O(1)
