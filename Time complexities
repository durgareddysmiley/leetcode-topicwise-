TIME COMPLEXITY
WHAT IS TIME COMPLEXITY?

Time complexity tells how the running time of an algorithm grows as the input size increases.
It does not measure seconds, it measures number of operations.

We write it using Big-O notation:

O(1) â†’ constant time

O(n) â†’ linear time

O(nÂ²) â†’ quadratic time (weâ€™ll see later)

ğŸŸ¢ O(1) â€” CONSTANT TIME

ğŸ‘‰ Time does NOT depend on input size

âœ… Code (O(1))
def get_first(arr):
    return arr[0]

ğŸ§  Dry Run (O(1))

Assume:

arr = [10, 20, 30, 40]


Step by step:

Access arr[0]

Return value

âœ… Only ONE operation

Now try bigger input:

arr = [1,2,3,4,5,6,7,8,9,10]


Still:

Access arr[0]

Return value

â¡ï¸ Still ONE operation

ğŸ”¥ Conclusion
Input size (n)	Operations
4	1
10	1
1,000,000	1

âœ… Time Complexity = O(1)
Because operations do not increase with n.

ğŸŸ¡ O(n) â€” LINEAR TIME

ğŸ‘‰ Time increases as input size increases

âœï¸ Edited Code
def print_all(arr):
    for x in arr:
        print(x)

ğŸ§  Dry Run (O(n))

Assume:

arr = [10, 20, 30, 40]


Step by step:

Print 10

Print 20

Print 30

Print 40

â¡ï¸ 4 operations

Now bigger input:

arr = [1,2,3,4,5,6,7,8]


Steps:

Print 1

Print 2

Print 3

Print 4

Print 5

Print 6

Print 7

Print 8

â¡ï¸ 8 operations

ğŸ”¥ Conclusion
Input size (n)	Operations
4	4
8	8
100	100

âœ… Time Complexity = O(n)
Because operations grow linearly with n.

ğŸ§© ONE MORE CLEAR COMPARISON (SIDE BY SIDE)
O(1)
print(arr[0])


Runs once

Independent of n

O(n)
for x in arr:
    print(x)


Runs n times

Depends on n

ğŸ”´ O(nÂ²) â€” QUADRATIC TIME

ğŸ‘‰ Time increases very fast because of nested loops

âœ… Base Code (O(1)) â€“ start simple
def print_first(arr):
    print(arr[0])

Dry Run

Only one print

No loop

âœ… O(1)

âœï¸ Edit the SAME CODE â†’ O(n)
def print_all(arr):
    for x in arr:
        print(x)

Dry Run (n = 3)
print 1
print 2
print 3


Operations = 3

âœ… O(n)

âœï¸ EDIT AGAIN â†’ O(nÂ²)
def print_pairs(arr):
    for i in range(len(arr)):
        for j in range(len(arr)):
            print(arr[i], arr[j])

ğŸ§  Dry Run (O(nÂ²))

Assume:

arr = [1, 2, 3]


n = 3

Step-by-step

i = 0

j = 0 â†’ (1,1)

j = 1 â†’ (1,2)

j = 2 â†’ (1,3)

i = 1

j = 0 â†’ (2,1)

j = 1 â†’ (2,2)

j = 2 â†’ (2,3)

i = 2

j = 0 â†’ (3,1)

j = 1 â†’ (3,2)

j = 2 â†’ (3,3)

ğŸ”¢ Operation Count

Outer loop â†’ runs n times

Inner loop â†’ runs n times

Total â†’ n Ã— n = nÂ²

n	Operations
3	9
5	25
10	100

âœ… Time Complexity = O(nÂ²)

ğŸ§  Easy Memory Line

Loop inside loop = O(nÂ²)

ğŸ”µ O(log n) â€” LOGARITHMIC TIME

ğŸ‘‰ Each step cuts input into half

âœï¸ Start with O(n) search
def linear_search(arr, target):
    for x in arr:
        if x == target:
            return True
    return False

Dry Run (n = 8)

Worst case â†’ check all 8 elements
âœ… O(n)

âœï¸ EDIT â†’ Binary Search (O(log n))

âš ï¸ Works on sorted array

def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2

        if arr[mid] == target:
            return True
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return False

ğŸ§  Dry Run (O(log n))

Assume:

arr = [1,2,3,4,5,6,7,8]
target = 7

Steps

1ï¸âƒ£ mid = 3 â†’ arr[3] = 4
â†’ target > 4 â†’ ignore left half

Remaining: [5,6,7,8]

2ï¸âƒ£ mid = 5 â†’ arr[5] = 6
â†’ target > 6 â†’ ignore left half

Remaining: [7,8]

3ï¸âƒ£ mid = 6 â†’ arr[6] = 7
âœ… found

ğŸ”¢ Operation Count
n	Steps
8	3
16	4
32	5

Each step â†’ divide by 2

âœ… Time Complexity = O(log n)

ğŸ§  Easy Memory Line

If input becomes half each time â†’ O(log n)

ğŸŸ£ O(n log n) â€” LINEARITHMIC TIME
ğŸ”¹ Meaning (very simple English)

You do log n work

for each of n elements

So:

n times Ã— log n work = O(n log n)

âœï¸ FINAL EDIT â†’ O(n log n)

Now we combine O(n) + O(log n)

def n_log_n(arr):
    for x in arr:          # runs n times
        n = len(arr)
        while n > 1:       # runs log n times
            n = n // 2

ğŸ§  Dry Run (O(n log n))

Assume:

arr = [1,2,3,4]
n = 4

Outer loop (n times)

Runs 4 times

Inner loop (log n times)

For each outer iteration:

4 â†’ 2 â†’ 1  (2 steps)

ğŸ”¢ Total operations
Outer	Inner	Total
4	2	8

Formula:

n Ã— log n


âœ… Time Complexity = O(n log n)

ğŸ”¥ REAL-LIFE EXAMPLE (VERY IMPORTANT)
ğŸŸ¢ Merge Sort â†’ O(n log n)

Why?

Divide array into halves â†’ log n

Merge n elements at each level

Total:

n work at each level Ã— log n levels
= O(n log n)

ğŸ§  Quick intuition

Loop (n)

Inside it, divide by 2 (log n)
ğŸ‘‰ O(n log n)

