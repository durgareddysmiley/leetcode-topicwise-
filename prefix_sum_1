üîπ Prefix Sum (Simple Definition)

A prefix sum is the running total of an array up to a certain index.

At each position, it stores the sum of all elements before and including that position.

üîπ When to Use Prefix Sum.  

We use prefix sums when we need to quickly calculate the sum of elements in a range.

Pattern Name ‚Üí Prefix Sum / Running Sum 

üîπ Definition of the Pattern

The prefix sum pattern is used when you need: 

The sum of elements from the start up to an index, or

The sum of elements in a range (l...r), quickly.

üëâ Idea: Precompute cumulative totals so that later queries are fast (O(1)) instead of recalculating every time.
A BUILT IN FUNCTION 
LEFT SUM CALCULATE BUILT IN FUNCTION 
Let us Assume arr = [1,2,3,4]
use built in like list(accumulate(arr))
NOW arr = [1,3,6,10]
RIGHT SUM CALCULATE BUILT IN FUNCTION 
arr = (1,2,3,4)
use built in like list(accumulate(arr[::-1])[::-1]
now arr = [10,9,7,4] 
I ALSO HAVE ONE DOUBT LIKE Y WE ARE ALSO DOING [::-1] 2 times 
Let's clear everything step-by-step, very simple, with English words ‚Äî so you understand prefix and suffix sums perfectly.


---

‚úÖ 1. What does accumulate(arr) mean?
 
For:

arr = [1, 2, 3, 4]

list(accumulate(arr)) produces prefix sums:

[1, 3, 6, 10]

Because:

1

1+2 = 3

1+2+3 = 6

1+2+3+4 = 10


This is left ‚Üí right cumulative sum.


---

‚úÖ 2. What does arr[::-1] mean?

It means reverse the array.

Example:

arr = [1, 2, 3, 4]
arr[::-1] ‚Üí [4, 3, 2, 1]


---

‚úÖ 3. What does accumulate(arr[::-1]) produce?

Reverse array:

[4,3,2,1]

Now do prefix sum on this:

[4, 7, 9, 10]

This is NOT yet correct suffix sum.
This is prefix sum of reversed array.


---

‚ùó 4. Why do we reverse again at the end?

We must bring the results back to the original order.

So:

list(accumulate(arr[::-1]))[::-1]

Becomes:

accumulate([4,3,2,1]) ‚Üí [4,7,9,10]
reverse again ‚Üí [10,9,7,4]

This is the suffix sum array.

Let's check:

Suffix sums of [1,2,3,4]:

From index 0: 1+2+3+4 = 10

From index 1:  2+3+4 = 9

From index 2:  3+4 = 7

From index 3:  4


So correct suffix array is:

[10, 9, 7, 4]

Which matches:

list(accumulate(arr[::-1]))[::-1]


---

üéØ So WHY do we need the second reverse?

Because:

accumulate(arr[::-1]) is the prefix sum of reversed array ‚Üí wrong order

Reversing it again fixes the order ‚Üí gives true suffix sums
 


---

‚ùå 5. Why a[i] in b is wrong?

Because ‚Äúin‚Äù only checks if value exists anywhere.

Example:

a = [1,3,6,10]
b = [10,9,7,4]

3 in b is False
10 in b is True but at wrong index!

We need:

a[i] == b[i]   # same position match

Pivot means:

sum from 1 ‚Üí x  ==  sum from x ‚Üí n

Both sums must match for the same x, that means same index, same position.


---

üî• Summary in one line

Expression	Meaning

accumulate(arr)	Left prefix sum
accumulate(arr[::-1])	Prefix sum of reversed array (wrong order)
accumulate(arr[::-1])[::-1]	Correct suffix sum



---

If you want, I can draw a picture explaining prefix vs suffix visually.

## REMEMBER TO DO ONE THING WHEN DOING PREFIX SUM PROBLEM 
IF WE DO PREFIX SUM PROBLEM RUNNING SUM PATTERN AFTER CALCLULATING PREFIX(LEFT OR RIGHT) THEN WE SEE CALCLUATED PREFIX AS INPUT TO WRITE LOGIC NOT INPUT GIVEN IN QUESTION 

2574. Left and Right Sum Differences 
------------------------------------
You are given a 0-indexed integer array nums of size n.

Define two arrays:
- leftSum[i]: sum of elements to the left of index i, or 0 if none.
- rightSum[i]: sum of elements to the right of index i, or 0 if none.

Return an array answer where answer[i] = |leftSum[i] - rightSum[i]|.

Constraints:
1 <= nums.length <= 1000
1 <= nums[i] <= 10^5
"""

"""
Examples:
---------
Input: nums = [10,4,8,3]
Output: [15,1,11,22]

Explanation:
leftSum  = [0, 10, 14, 22]
rightSum = [15, 11, 3, 0]
answer   = [|0-15|, |10-11|, |14-3|, |22-0|] = [15,1,11,22]

## CODE 
class Solution:
    def leftRightDifference(self, nums: List[int]) -> List[int]:
        ls = [0] * (len(nums))
        for i in range(len(nums)-1):
            ls[i+1] = nums[i] + ls[i]
        rs = [0] * len(nums)
        for i in range(len(nums)-2,-1,-1):
            rs[i] = rs[i+1] + nums[i+1]
        c = []
        for i in range(0,len(nums)):
            c.append(abs(rs[i] - ls[i]))
        return c

1480. Running Sum of 1d Array
-----------------------------
Given an array nums. A running sum is defined as:
runningSum[i] = sum(nums[0]‚Ä¶nums[i]).

Return the running sum of nums.

Constraints:
1 <= nums.length <= 1000
-10^6 <= nums[i] <= 10^6
"""

"""
Examples:
---------
Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: [1, (1+2), (1+2+3), (1+2+3+4)].

Approach:
---------
1. Create a prefix sum array (running sum).
2. First element stays same.
3. Each next element = previous running sum + current element.
4. Return the prefix sum array.

Time: O(n)
Space: O(n) (can be reduced to O(1) if we modify nums directly).
"""
## CODE 
from typing import List

class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        ps = [0] * len(nums)
        ps[0] = nums[0]
        
        for i in range(1, len(nums)):
            ps[i] = ps[i-1] + nums[i]
        
        return ps
"""
2485. Find the Pivot Integer
----------------------------
Given a positive integer n, find the pivot integer x such that:

The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.
Return x if it exists, else -1.

Constraints:
1 <= n <= 1000
"""

"""
Examples:
---------
Input: n = 8
Output: 6
Explanation: 1+2+3+4+5+6 = 6+7+8 = 21

Approach:
---------
Pattern: Prefix Sum / Running Sum
1. Create a prefix sum array for numbers 1 to n.
2. For each x from 1 to n:
   - left sum = prefix[x]
   - right sum = prefix[n] - prefix[x-1]
   - if left sum == right sum, return x
3. If no such x, return -1

Time: O(n)
Space: O(n)
"""
## CODE 
class Solution:
    def pivotInteger(self, n: int) -> int:
        # Step 1: Build prefix sum array
        prefix = [0] * (n+1)
        nums = [i for i in range(1, n+1)]
        
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
        
        # Step 2: Find pivot
        for x in range(1, n+1):
            left_sum = prefix[x]
            right_sum = prefix[n] - prefix[x-1]
            if left_sum == right_sum:
                return x
        return -1
LeetCode Problem 1588: Sum of All Odd Length Subarrays

Problem:
Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr.

Example 1:
Input: arr = [1,4,2,5,3]
Output: 58
Explanation: Odd-length subarrays are:
[1], [4], [2], [5], [3], [1,4,2], [4,2,5], [2,5,3], [1,4,2,5,3]
Sum = 58

## CODE TIME COMPLEXITY 0(N * 2) 
class Solution:
    def sumOddLengthSubarrays(self, arr: List[int]) -> int:
        n = len(arr)
        prefix = [0] * (n + 1)  # prefix sum array
        total = 0
        
        # Build prefix sum array
        for i in range(n):
            prefix[i + 1] = prefix[i] + arr[i]
        
        # Iterate over all odd lengths
        for length in range(1, n + 1, 2):
            for start in range(n - length + 1):
                total += prefix[start + length] - prefix[start]  # sum of subarray

        return total
OPTIMISED CODE 0(N) 
class Solution:
    def sumOddLengthSubarrays(self, arr: List[int]) -> int:
        n = len(arr)
        total = 0
        for i, val in enumerate(arr):
            total_subarrays = (i + 1) * (n - i)
            odd_subarrays = (total_subarrays + 1) // 2
            total += val * odd_subarrays
        return total
## THIS IS SLIDING WINDOW + PREFIX SUM LEET CODE 1838 
MY CONFUSION IS CANT UNDER STAND PREFIX SUM FORMULAS LIKE   (pref[r+1] - pref[l]) NOW I WANT TO GET CLARITY 

"""
‚úÖ LOGIC TO REMEMBER:

Always store prefix like: pref[i+1] = pref[i] + nums[i]

Subarray sum formula: sum(l..r) = pref[r+1] - pref[l]
HOW THESE SUB ARRAY SUM FORMULA WORKS
arr = [1,2,4]
left_prefix = [0,1,3,7]
Subarray sum formula: sum(l..r) = pref[r+1] - pref[l]
i want sum of 1,2 in arr then we need to use prefix to get the sum in arr
in 1,2...1 cames first index 0..No change in first one==pre[l]
and 2 is last index 1..last index + 1 == pre[r+1
## Y R+1 FOR LEFT DORECT WE ARE TAKING BUT IN WIGHT Y R+1
BECAUSE pref[i] = sum of elements from arr[0] to arr[i-1] 
Notice the ‚Äúi-1‚Äù.

That means:

pref[1] contains sum of arr[0]

pref[2] contains sum of arr[0] + arr[1]

pref[3] contains sum of arr[0] + arr[1] + arr[2]


So to include arr[r], you need prefix at position r + 1.


## WHY DOES THIS WORK?

pref[r+1] = sum of first (r+1) elements = nums[0] + ... + nums[r]

pref[l] = sum of first l elements = nums[0] + ... + nums[l-1]

## TO REMEMBER 
If all numbers became nums[r] (SAME), then the total sum of the subarray would be:
EXPECTED = (R-L+1) * NUM[R]
// PROBLEM 
LeetCode 1838. Frequency of the Most Frequent Element

The frequency of an element is the number of times it occurs in an array.
You are given an integer array nums and an integer k.

In one operation, you can choose an index of nums and increment the element at that index by 1.

Return the maximum possible frequency of an element after performing at most k operations.

--------------------------------------------------
Example 1:
Input: nums = [1,2,4], k = 5
Output: 3
Explanation: Increment the first element 3 times and the second element 2 times ‚Üí nums = [4,4,4].
So, frequency of 4 = 3.
Constraints:
1 <= nums.length <= 10^5
1 <= nums[i] <= 10^5
1 <= k <= 10^5

## CODE 
from typing import List

class Solution:
    def maxFrequency(self, nums: List[int], k: int) -> int:
        nums.sort()                       # 1) sort array in non-decreasing order
        n = len(nums)                     # 2) length

        # Build prefix sum
        pref = [0] * (n+1)                # 3) pref[0]=0, pref[i] = sum(nums[0..i-1])
        for i in range(n):
            pref[i+1] = pref[i] + nums[i] # 4) fill prefix sums

        res = 1                           # 5) result at least 1
        l = 0                             # 6) left pointer of window
        for r in range(n):                # 7) expand right pointer
            # cost to make nums[l..r] all equal nums[r]
            total = (r-l+1) * nums[r] - (pref[r+1] - pref[l])  # 8)
            while total > k:              # 9) if cost too large, shrink from left
                l += 1
                total = (r-l+1) * nums[r] - (pref[r+1] - pref[l])
            res = max(res, r-l+1)         # 10) update answer
        return res                        # 11) return final answer

