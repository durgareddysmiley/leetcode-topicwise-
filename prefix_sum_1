ðŸ”¹ Prefix Sum (Simple Definition)

A prefix sum is the running total of an array up to a certain index.

At each position, it stores the sum of all elements before and including that position.

ðŸ”¹ When to Use Prefix Sum

We use prefix sums when we need to quickly calculate the sum of elements in a range.

Pattern Name â†’ Prefix Sum / Running Sum

ðŸ”¹ Definition of the Pattern

The prefix sum pattern is used when you need:

The sum of elements from the start up to an index, or

The sum of elements in a range (l...r), quickly.

ðŸ‘‰ Idea: Precompute cumulative totals so that later queries are fast (O(1)) instead of recalculating every time.

## REMEMBER TO DO ONE THING WHEN DOING PREFIX SUM PROBLEM 
IF WE DO PREFIX SUM PROBLEM RUNNING SUM PATTERN AFTER CALCLULATING PREFIX(LEFT OR RIGHT) THEN WE SEE CALCLUATED PREFIX AS INPUT TO WRITE LOGIC NOT INPUT GIVEN IN QUESTION 

2574. Left and Right Sum Differences
------------------------------------
You are given a 0-indexed integer array nums of size n.

Define two arrays:
- leftSum[i]: sum of elements to the left of index i, or 0 if none.
- rightSum[i]: sum of elements to the right of index i, or 0 if none.

Return an array answer where answer[i] = |leftSum[i] - rightSum[i]|.

Constraints:
1 <= nums.length <= 1000
1 <= nums[i] <= 10^5
"""

"""
Examples:
---------
Input: nums = [10,4,8,3]
Output: [15,1,11,22]

Explanation:
leftSum  = [0, 10, 14, 22]
rightSum = [15, 11, 3, 0]
answer   = [|0-15|, |10-11|, |14-3|, |22-0|] = [15,1,11,22]

## CODE 
class Solution:
    def leftRightDifference(self, nums: List[int]) -> List[int]:
        ls = [0] * (len(nums))
        for i in range(len(nums)-1):
            ls[i+1] = nums[i] + ls[i]
        rs = [0] * len(nums)
        for i in range(len(nums)-2,-1,-1):
            rs[i] = rs[i+1] + nums[i+1]
        c = []
        for i in range(0,len(nums)):
            c.append(abs(rs[i] - ls[i]))
        return c

1480. Running Sum of 1d Array
-----------------------------
Given an array nums. A running sum is defined as:
runningSum[i] = sum(nums[0]â€¦nums[i]).

Return the running sum of nums.

Constraints:
1 <= nums.length <= 1000
-10^6 <= nums[i] <= 10^6
"""

"""
Examples:
---------
Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: [1, (1+2), (1+2+3), (1+2+3+4)].

Approach:
---------
1. Create a prefix sum array (running sum).
2. First element stays same.
3. Each next element = previous running sum + current element.
4. Return the prefix sum array.

Time: O(n)
Space: O(n) (can be reduced to O(1) if we modify nums directly).
"""
## CODE 
from typing import List

class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        ps = [0] * len(nums)
        ps[0] = nums[0]
        
        for i in range(1, len(nums)):
            ps[i] = ps[i-1] + nums[i]
        
        return ps
"""
2485. Find the Pivot Integer
----------------------------
Given a positive integer n, find the pivot integer x such that:

The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.
Return x if it exists, else -1.

Constraints:
1 <= n <= 1000
"""

"""
Examples:
---------
Input: n = 8
Output: 6
Explanation: 1+2+3+4+5+6 = 6+7+8 = 21

Approach:
---------
Pattern: Prefix Sum / Running Sum
1. Create a prefix sum array for numbers 1 to n.
2. For each x from 1 to n:
   - left sum = prefix[x]
   - right sum = prefix[n] - prefix[x-1]
   - if left sum == right sum, return x
3. If no such x, return -1

Time: O(n)
Space: O(n)
"""
## CODE 
class Solution:
    def pivotInteger(self, n: int) -> int:
        # Step 1: Build prefix sum array
        prefix = [0] * (n+1)
        nums = [i for i in range(1, n+1)]
        
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
        
        # Step 2: Find pivot
        for x in range(1, n+1):
            left_sum = prefix[x]
            right_sum = prefix[n] - prefix[x-1]
            if left_sum == right_sum:
                return x
        return -1
LeetCode Problem 1588: Sum of All Odd Length Subarrays

Problem:
Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr.

Example 1:
Input: arr = [1,4,2,5,3]
Output: 58
Explanation: Odd-length subarrays are:
[1], [4], [2], [5], [3], [1,4,2], [4,2,5], [2,5,3], [1,4,2,5,3]
Sum = 58

## CODE TIME COMPLEXITY 0(N * 2) 
class Solution:
    def sumOddLengthSubarrays(self, arr: List[int]) -> int:
        n = len(arr)
        prefix = [0] * (n + 1)  # prefix sum array
        total = 0
        
        # Build prefix sum array
        for i in range(n):
            prefix[i + 1] = prefix[i] + arr[i]
        
        # Iterate over all odd lengths
        for length in range(1, n + 1, 2):
            for start in range(n - length + 1):
                total += prefix[start + length] - prefix[start]  # sum of subarray

        return total
OPTIMISED CODE 0(N) 
class Solution:
    def sumOddLengthSubarrays(self, arr: List[int]) -> int:
        n = len(arr)
        total = 0
        for i, val in enumerate(arr):
            total_subarrays = (i + 1) * (n - i)
            odd_subarrays = (total_subarrays + 1) // 2
            total += val * odd_subarrays
        return total


