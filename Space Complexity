Space Complexity

Space complexity tells how much extra memory an algorithm uses apart from input data.
BIG-O NOTATION
Big-O describes the worst-case growth of an algorithm when input size becomes large.

##SPACE COMPLEXITY 
1. CONSTANT SPACE O(1) – Dry Run
def sum_array(arr):
    total = 0
    for x in arr:
        total += x
    return total

Input example:
arr = [2, 4, 6]

Step-by-step execution
Step	Operation	total value	Memory explanation
1	Initialize total	0	One variable created → O(1)
2	x = 2 (first loop)	total = 0 + 2 = 2	No new memory created, just update existing total
3	x = 4 (second loop)	total = 2 + 4 = 6	Same total variable updated, memory still constant
4	x = 6 (third loop)	total = 6 + 6 = 12	Still the same variable, no extra memory per element
5	Return total	12	Only one variable exists → O(1)
Why space is O(1)

total does not multiply with array size.

Whether arr has 3 elements or 3 million, memory used by total = 1 variable.

The loop variable x is temporary and overwrites itself each iteration.

No extra arrays or recursion are used.

✅ Maximum memory never grows with n → O(1)

2. Linear Space O(n) – Dry Run
def double_array(arr):
    new_arr = []
    for x in arr:
        new_arr.append(x * 2)
    return new_arr

Input example:
arr = [2, 4, 6]

Step-by-step execution
Step	Operation	new_arr value	Memory explanation
1	Initialize new_arr	[]	Empty array created → memory proportional to 0 now
2	x = 2 (first loop)	[4]	Added 1 element → extra memory grows with input
3	x = 4 (second loop)	[4, 8]	Added another element → memory grows linearly
4	x = 6 (third loop)	[4, 8, 12]	Added another element → memory still grows with n
5	Return new_arr	[4, 8, 12]	Array contains 3 elements → memory = 3 elements
Why space is O(n)

new_arr grows as input grows

If arr has 3 elements → new_arr has 3 elements

If arr has 1,000 elements → new_arr has 1,000 elements

Memory is proportional to n

Each element in new_arr takes space → total memory = n units

Loop variable x is temporary
 
Overwrites itself each iteration → does not add extra space

No recursion used

Only the array contributes to memory growth

✅ Maximum memory grows linearly with input → O(n)

3. Recursive O(n)
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n-1)


Input example: n = 3

Step	Operation	Stack content	Memory explanation
1	factorial(3) called	factorial(3) waiting	1 stack frame
2	factorial(2) called	factorial(3), factorial(2) waiting	2 stack frames
3	factorial(1) called	factorial(3), factorial(2), factorial(1) waiting	3 stack frames
4	factorial(0) called	factorial(3), factorial(2), factorial(1), factorial(0) waiting	4 stack frames
5	factorial(0) returns 1	start returning	stack frames removed one by one

✅ Why O(n): Each recursive call adds a stack frame; max depth = n → memory grows linearly.
THIS IS 0(N) BECAUSE factorial(3) , factorial(2),factorial(1) these are new boxes creating every time how many times n there  they want to create   

7. Nested loops O(1)  ##REMEMBER MORE LOOPS != MORE SPACE 
def count_pairs(n):
    count = 0
    for i in range(n):
        for j in range(n):
            count += 1
    return count


Input example: n = 3

Step	Operation	Variables	Memory explanation
Loop	All iterations	count variable	Only 1 variable used; loops do not create extra memory

✅ Why O(1): Loops affect time, not space; only count exists. 

