PREFIX SUM + HASHING Pattern                
 
Hashing (usually using a Map or unordered_map) is combined with prefix sums to solve problems like:

Subarray with a given sum    

Number of subarrays with sum = K

Longest subarray with sum = 0 

Key idea:  
  
Maintain a prefix sum while iterating through the array.

Use a hash map to store the frequency or first occurrence of each prefix sum.

Check if (current_prefix_sum - target_sum) exsts in the map.

ğŸ”‘ Clues that a problem needs Prefix Sum + HashMap

1. The question is about subarrays

Not subsequences, not subsets â€” specifically continuous subarrays.
 
Examples in statements:
 
â€œFind the number of subarrays â€¦â€

â€œFind the longest subarray â€¦â€

â€œCheck if a subarray exists â€¦â€


2. The subarray condition involves sum

Something like:

Sum = target

Sum divisible by k

Sum modulo something

Equal number of 0s and 1s (can be turned into sum = 0)


3. You need counting or longest length

##TRICK 
ğŸ”‘ Key Difference

Target sum is given (560, 930) â†’ use prefix - goal

Target sum is not given, only divisibility (974) â†’ use prefix % k

##PROBLEM 
ğŸ”¹ Subarray Sum Equals K (LeetCode 560)
âœ… Problem Statement

Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals k.

âœ… Example Input
nums = [1, 1, 1]
k = 2

âœ… Expected Output
2

âœ… Explanation

Subarrays with sum = 2 are:

[1, 1] (index 0 to 1)

[1, 1] (index 1 to 2)

So the answer is 2.

If the problem asks:

How many subarrays â€¦ â†’ count â†’ use hashmap with frequencies
##CODE
from collections import defaultdict
from typing import List

from collections import defaultdict

class Solution:
    def subarraySum(self, nums: list[int], k: int) -> int:
        final = c = 0 
        hashi = defaultdict(int)
        hashi[0]+=1 
        for i in range(len(nums)):
            c+=nums[i]
            if c - k in hashi:
                final += hashi[c-k]
            hashi[c]+=1
        return final
##SOLUTION 
EE SUM CHESTUNNAPUDU NEN CHESINA MISTAKE NORMAL GA NUMBER HASH LOKI ADD CHESA WITH OUT COMPARING SO OLD ANSWERS KUDA MALLI ADD IYYI OUT PUT EKKUVA CHUPISTUNDHI SO DIRECT PREFIX SUM HASH LOKI ADD CHESTE OLD SUMS RAVU REMEMBER 

##BIG DOUBT IN PREFIX SUM -- IS WE DO  (prefix_sum - k)  AND ADDING TO COUNT HOW IT IS WILL BE SUBARAY NOT SUBSEQUENCE 
$$ DOUBT ANSWER === BELOW 
Array: arr = [1, 2, 3, 4], K = 5

We want subarrays whose sum = 5.

Step 1: Keep a running total (prefix sum)
Index	arr[i]	Running total (prefix_sum)
0	     1	       1
1	     2	       3 
2	     3	       6 
3	     4       	10
Step 2: Check if there is a previous total so that the difference = K

At each step, we do:

current total - previous total = K â†’ thatâ€™s our subarray sum.

Step-by-step:

Step 0: total = 1 â†’ 1 - ? = 5 â†’ no previous total matches â†’ nothing

Step 1: total = 3 â†’ 3 - ? = 5 â†’ no previous total matches â†’ nothing

Step 2: total = 6 â†’ 6 - ? = 5 â†’ ? = 1 â†’ previous total 1 exists (at index 0)

This means the numbers after index 0 up to current index 2 sum to 5 â†’ [2, 3]

Step 3: total = 10 â†’ 10 - ? = 5 â†’ ? = 5 â†’ previous total 5 not found â†’ nothing

Step 3: Why itâ€™s a subarray, not a subsequence

The prefix sum always counts all numbers from the start.

When we subtract a previous total, we are literally taking all numbers between that previous index + 1 and current index.

We cannot skip numbers, so itâ€™s always contiguous â†’ a subarray.

Think of it like a rope of numbers:

[1, 2, 3, 4]
 ^     ^
start  end


prefix_sum at end - prefix_sum at start â†’ includes all numbers in between â†’ you are grabbing a continuous piece of rope â†’ subarray.

Longest subarray â€¦ â†’ length â†’ use hashmap with indices

## ğŸ”¹ 930. Binary Subarrays With Sum
Problem

Given a binary array nums (only 0s and 1s) and an integer goal, return the number of subarrays with sum = goal.
(Subarray = contiguous part of array)

Example 1
Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are:
[1,0,1], [0,1,0,1], [1,0,1,0], [1,0,1]

## CODE 
class Solution:
    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
        hash = defaultdict(int)
        hash[0] = 1
        pre = rem = count = 0
        for i in range(len(nums)):
            pre+=nums[i]
            if pre - goal in hash:
                count+=hash[pre-goal]
            hash[pre]+=1
        return count
## MY DOUBTS IN ABOVE SUM 
  ans += prefix_map[prefix_sum - goal] WE CAN WRITE THIS USING IF ALSO ANY HOW NO PROBLEM..  ans += prefix_map[prefix_sum - goal] WE WILL ADD IN ANS INSTANTLY 
LETS ASSUME ANS IS 5 and pre - goal is again satisfied then ans is 5 + 5 i think that how it will increases beacause the new element added and add 5 new pairs beacause 
all 5 have same remainder then we get 5 + 5 = 10

974. Subarray Sums Divisible by K
ğŸ“ Problem Statement

Given an integer array nums and an integer k, return the number of non-empty subarrays whose sum is divisible by k.

A subarray is a contiguous part of an array.

ğŸ” Example 1

Input:

nums = [4, 5, 0, -2, -3, 1]
k = 5


Output:

7


Explanation:
There are 7 subarrays with sum divisible by 5:

[4, 5, 0, -2, -3, 1]

[5]

[5, 0]

[5, 0, -2, -3]

[0]

[0, -2, -3]

[-2, -3]

ğŸ” Example 2

Input:

nums = [5]
k = 9


Output:

0

âœ… Constraints

1 <= nums.length <= 30,000

-10â´ <= nums[i] <= 10â´

2 <= k <= 10â´

ğŸ§  Approach (Prefix Sum + Remainder Frequency)

Use a prefix sum to track the running sum.

Compute prefix % k at each step.

If the same remainder appears again, it means the subarray between them has a sum divisible by k.

Use a hashmap to store counts of remainders.

Count how many times each remainder has been seen before.

This reduces the problem to O(n) time.

ğŸ§¾ Python Solution
from collections import defaultdict

class Solution:
    def subarraysDivByK(self, nums: List[int], k: int) -> int:
        freq = defaultdict(int)
        freq[0] = 1  # remainder 0 seen once (empty prefix)
        
        prefix = 0
        count = 0
        
        for num in nums:
            prefix += num
            rem = prefix % k
            
            # If remainder was seen earlier, add its frequency
            count += freq[rem]
            
            # Increase remainder count
            freq[rem] += 1 // This is remainder while doing this sum  i stored prefix sums so i have doubt and that doubt cleared by the below explanation 
        
        return count

ğŸ“Œ Time Complexity

O(n) â€” one pass through the array

ğŸ“Œ Space Complexity

O(k) â€” hashmap storing remainders

âœ… WHY keys must be remainders (NOT prefix sums)
ğŸ”¥ Rule:

A subarray sum is divisible by k if and only if:

prefix[j] % k == prefix[i] % k


This means:

(prefix[j] - prefix[i]) % k = 0


Which exactly means the subarray (i+1 â€¦ j) sum is divisible by k.

ğŸ‘‰ So we must store remainders, because checking equal remainders is how we detect a divisible subarray.

ğŸ§  Letâ€™s prove this with your example:

arr = [4, 5, 0, -2, -3, 1], k = 5

Prefix sums:

index	element	prefixsum	remainder
0	      4	      4	       4
1	      5	      9	       4
2	      0	      9	       4
3	      -2	     7	       2
4	      -3	     4	       4
5	       1	     5	        0

Look at indices with same remainder:

remainder 4 appears at indices: 0,1,2,4

remainder 2 at index: 3

remainder 0 at index: 5

Now check subarrays formed by same-remainder pairs:

remainder 4:

(0 â†’ 1): subarray [5] â†’ 5 â†’ divisible

(0 â†’ 2): subarray [5,0] â†’ 5 â†’ divisible

(0 â†’ 4): subarray [5,0,-2,-3] â†’ 5 â†’ divisible

(1 â†’ 2): subarray [0] â†’ 0 â†’ divisible

(1 â†’ 4): subarray [0,-2,-3] â†’ -5 â†’ divisible

(2 â†’ 4): subarray [-2,-3] â†’ -5 â†’ divisible

remainder 0:

(â€“1 â†’ 5): whole subarray â†’ sum = 5 â†’ divisible

ğŸ‘‰ 7 subarrays found, EXACTLY the output.

## UPTO ABOVE SUM WE SEEN COUNTING THEN WE USE prefix_sum[0] = 1 BUT NOW WE ARE DOING prefix_sum[0] = -1 BECAUSE NOW WE ARE DEALING WITH TO FIND LENGTH LIKE LONGEST AND SHORTEST 
## WHEN ASK ABOUT LONGEST THEN  WE  WRITE  INSIDE  ELSE  hash[rem] = i..IF WE WANT SHORTEST  WE DOESNOT WRITE IN ELSE  WE WRITE IN IF BELOW 
âœ… 2. prefix_sum[0] = -1 â†’ Used for LENGTH (Longest/Shortest)

When the question asks:

Longest subarray

Shortest subarray

Then we store:

hash[0] = -1


Why? // OKA NUMBER KE 0 IYNAPPUDU LIKE 1 2 3 HERE IT IS 0 AND LENGTH IS 2 THE  2 - (-1) IS 3 IN THAT TIMES WE WILL USE MORE CLEAR IS MENTIONED BELOW

Because if prefix remainder becomes 0 at index i:

longest length = i - (-1)

shortest length = same logic

So storing -1 acts like a "virtual index before start".

âœ… Why hash[0] = -1 for LONGEST/SHORTEST?
ğŸ‘‰ Because we want to include subarrays starting from index 0.

Example:

arr = [2, 3]
K = 5
prefix sums = [2, 5]
remainders = [2, 0]


At index 1, remainder = 0.
This means:

subarray 0 to 1 is valid


Now length must be:

length = i - (-1) 
       = 1 - (-1)
       = 2

âœ” Correct length = 2
âŒ Without -1: 1 - 0 = 1 (wrong)

1590. MAKE SUM DIVISIBLE BY P 
Problem

Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.

Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.

A subarray is defined as a contiguous block of elements in the array.

Examples

Example 1:

Input: nums = [3,1,4,2], p = 6
Output: 1
Explanation: Remove [4]. Remaining sum = 6, divisible by 6.

## CODE 
from collections import defaultdict
from typing import List
class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        sumi = sum(nums) % p     # target remainder
        pre = rem = 0
        if sumi % p == 0:        # already divisible
            return 0
        mini = float('inf')
        hash = defaultdict(int)
        hash[0]= -1              # for shortest subarray
        
        for i in range(len(nums)):
            pre += nums[i]
            rem = pre % p
        
            # Needed = (current_rem - target) % p
            if (rem - sumi) % p in hash:
                mini = min(mini, i - hash[(rem-sumi)%p])
            
            hash[rem] = i
        
        return mini if mini != float('inf') and mini < len(nums) else -1


## DOUBTS IN ABOVE SUM    target = (rem - total_mod) % p.. WE ARE DOING %p just to avoid negatives  
If two prefix sums have the SAME remainder, the subarray between them is divisible by p.



