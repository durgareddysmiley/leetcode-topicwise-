PREFIX SUM + HASHING Pattern

Hashing (usually using a Map or unordered_map) is combined with prefix sums to solve problems like:

Subarray with a given sum

Number of subarrays with sum = K

Longest subarray with sum = 0

Key idea:

Maintain a prefix sum while iterating through the array.

Use a hash map to store the frequency or first occurrence of each prefix sum.

Check if (current_prefix_sum - target_sum) exists in the map.

🔑 Clues that a problem needs Prefix Sum + HashMap

1. The question is about subarrays

Not subsequences, not subsets — specifically continuous subarrays.

Examples in statements:

“Find the number of subarrays …”

“Find the longest subarray …”

“Check if a subarray exists …”


2. The subarray condition involves sum

Something like:

Sum = target

Sum divisible by k

Sum modulo something

Equal number of 0s and 1s (can be turned into sum = 0)


3. You need counting or longest length

##PROBLEM 
974. Subarray Sums Divisible by K

Difficulty: Medium
Topics: Array, Hash Map, Prefix Sum

Problem

Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.

A subarray is a contiguous part of an array.

Example 1
Input: nums = [4,5,0,-2,-3,1], k = 5
Output: 7
Explanation: There are 7 subarrays with a sum divisible by 5:

If the problem asks:

How many subarrays … → count → use hashmap with frequencies
##CODE
from collections import defaultdict
from typing import List

from collections import defaultdict

def subarraySum(nums, k):
    prefix_sum = 0
    count = 0
    prefix_map = defaultdict(int)
    prefix_map[0] = 1   # base case: empty subarray

    for num in nums:
        prefix_sum += num
        if (prefix_sum - k) in prefix_map:
            count += prefix_map[prefix_sum - k]
        prefix_map[prefix_sum] += 1
    
    return count

##BIG DOUBT IN PREFIX SUM -- IS WE DO  (prefix_sum - k)  AND ADDING TO COUNT HOW IT IS WILL BE SUBARAY NOT SUBSEQUENCE 
Array: arr = [1, 2, 3, 4], K = 5

We want subarrays whose sum = 5.

Step 1: Keep a running total (prefix sum)
Index	arr[i]	Running total (prefix_sum)
0	     1	       1
1	     2	       3 
2	     3	       6 
3	     4       	10
Step 2: Check if there is a previous total so that the difference = K

At each step, we do:

current total - previous total = K → that’s our subarray sum.

Step-by-step:

Step 0: total = 1 → 1 - ? = 5 → no previous total matches → nothing

Step 1: total = 3 → 3 - ? = 5 → no previous total matches → nothing

Step 2: total = 6 → 6 - ? = 5 → ? = 1 → previous total 1 exists (at index 0)

This means the numbers after index 0 up to current index 2 sum to 5 → [2, 3]

Step 3: total = 10 → 10 - ? = 5 → ? = 5 → previous total 5 not found → nothing

Step 3: Why it’s a subarray, not a subsequence

The prefix sum always counts all numbers from the start.

When we subtract a previous total, we are literally taking all numbers between that previous index + 1 and current index.

We cannot skip numbers, so it’s always contiguous → a subarray.

Think of it like a rope of numbers:

[1, 2, 3, 4]
 ^     ^
start  end


prefix_sum at end - prefix_sum at start → includes all numbers in between → you are grabbing a continuous piece of rope → subarray.

Longest subarray … → length → use hashmap with indices

## 🔹 930. Binary Subarrays With Sum
Problem

Given a binary array nums (only 0s and 1s) and an integer goal, return the number of subarrays with sum = goal.
(Subarray = contiguous part of array)

Example 1
Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are:
[1,0,1], [0,1,0,1], [1,0,1,0], [1,0,1]

## CODE 
from collections import defaultdict
from typing import List

class Solution:
    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
        prefix_map = defaultdict(int)
        prefix_map[0] = 1
        prefix_sum = 0
        ans = 0

        for num in nums:
            prefix_sum += num
            ans += prefix_map[prefix_sum - goal]
            prefix_map[prefix_sum] += 1

        return ans
