PREFIX SUM + HASHING Pattern

Hashing (usually using a Map or unordered_map) is combined with prefix sums to solve problems like:

Subarray with a given sum

Number of subarrays with sum = K

Longest subarray with sum = 0

Key idea:

Maintain a prefix sum while iterating through the array.

Use a hash map to store the frequency or first occurrence of each prefix sum.

Check if (current_prefix_sum - target_sum) exists in the map.

🔑 Clues that a problem needs Prefix Sum + HashMap

1. The question is about subarrays

Not subsequences, not subsets — specifically continuous subarrays.

Examples in statements:

“Find the number of subarrays …”

“Find the longest subarray …”

“Check if a subarray exists …”


2. The subarray condition involves sum

Something like:

Sum = target

Sum divisible by k

Sum modulo something

Equal number of 0s and 1s (can be turned into sum = 0)


3. You need counting or longest length

##PROBLEM 
974. Subarray Sums Divisible by K

Difficulty: Medium
Topics: Array, Hash Map, Prefix Sum

Problem

Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.

A subarray is a contiguous part of an array.

Example 1
Input: nums = [4,5,0,-2,-3,1], k = 5
Output: 7
Explanation: There are 7 subarrays with a sum divisible by 5:

If the problem asks:

How many subarrays … → count → use hashmap with frequencies
##CODE
from collections import defaultdict
from typing import List

from collections import defaultdict

def subarraySum(nums, k):
    prefix_sum = 0
    count = 0
    prefix_map = defaultdict(int)
    prefix_map[0] = 1   # base case: empty subarray

    for num in nums:
        prefix_sum += num
        if (prefix_sum - k) in prefix_map:
            count += prefix_map[prefix_sum - k]
        prefix_map[prefix_sum] += 1
    
    return count

##BIG DOUBT IN PREFIX SUM -- IS WE DO  (prefix_sum - k)  AND ADDING TO COUNT HOW IT IS WILL BE SUBARAY NOT SUBSEQUENCE 
Array: arr = [1, 2, 3, 4], K = 5

We want subarrays whose sum = 5.

Step 1: Keep a running total (prefix sum)
Index	arr[i]	Running total (prefix_sum)
0	     1	       1
1	     2	       3 
2	     3	       6 
3	     4       	10
Step 2: Check if there is a previous total so that the difference = K

At each step, we do:

current total - previous total = K → that’s our subarray sum.

Step-by-step:

Step 0: total = 1 → 1 - ? = 5 → no previous total matches → nothing

Step 1: total = 3 → 3 - ? = 5 → no previous total matches → nothing

Step 2: total = 6 → 6 - ? = 5 → ? = 1 → previous total 1 exists (at index 0)

This means the numbers after index 0 up to current index 2 sum to 5 → [2, 3]

Step 3: total = 10 → 10 - ? = 5 → ? = 5 → previous total 5 not found → nothing

Step 3: Why it’s a subarray, not a subsequence

The prefix sum always counts all numbers from the start.

When we subtract a previous total, we are literally taking all numbers between that previous index + 1 and current index.

We cannot skip numbers, so it’s always contiguous → a subarray.

Think of it like a rope of numbers:

[1, 2, 3, 4]
 ^     ^
start  end


prefix_sum at end - prefix_sum at start → includes all numbers in between → you are grabbing a continuous piece of rope → subarray.

Longest subarray … → length → use hashmap with indices

## 🔹 930. Binary Subarrays With Sum
Problem

Given a binary array nums (only 0s and 1s) and an integer goal, return the number of subarrays with sum = goal.
(Subarray = contiguous part of array)

Example 1
Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are:
[1,0,1], [0,1,0,1], [1,0,1,0], [1,0,1]

## CODE 
from collections import defaultdict
from typing import List

class Solution:
    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
        prefix_map = defaultdict(int)
        prefix_map[0] = 1
        prefix_sum = 0
        ans = 0

        for num in nums:
            prefix_sum += num
            ans += prefix_map[prefix_sum - goal]
            prefix_map[prefix_sum] += 1

        return ans

## UPTO ABOVE SUM WE SEEN COUNTING THEN WE USE prefix_sum[0] = 1 BUT NOW WE ARE DOING prefix_sum[0] = -1 BECAUSE NOW WE ARE DEALING WITH TO FIND LENGTH LIKE LONGEST AND SHORTEST 
## WHEN ASK ABOUT LONGEST THEN  WE  WRITE  INSIDE  ELSE  hash[rem] = i..IF WE WANT SHORTEST  WE DOESNOT WRITE IN ELSE  WE WRITE IN IF BELOW 
1590. Make Sum Divisible by P
Problem

Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.

Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.

A subarray is defined as a contiguous block of elements in the array.

Examples

Example 1:

Input: nums = [3,1,4,2], p = 6
Output: 1
Explanation: Remove [4]. Remaining sum = 6, divisible by 6.

## CODE 
from collections import defaultdict
from typing import List

class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        total_mod = sum(nums) % p
        if total_mod == 0:
            return 0
        
        prefix_sum = 0
        min_len = float('inf')
        mod_index = {0: -1}
        
        for i, num in enumerate(nums):
            prefix_sum += num
            rem = prefix_sum % p
            target = (rem - total_mod) % p
            if target in mod_index:
                min_len = min(min_len, i - mod_index[target])
            mod_index[rem] = i
        return min_len if min_len < len(nums) else -1

## DOUBTS IN ABOVE SUM    target = (rem - total_mod) % p.. WE ARE DOING %p just to avoid negatives  


