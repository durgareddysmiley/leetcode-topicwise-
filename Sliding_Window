## Sliding Window
Definition

A Sliding Window is a technique used to solve problems involving arrays, strings, or lists, where you want to find subarrays or substrings that satisfy a certain condition (like sum, length, maximum, minimum, etc.).

Instead of using nested loops, we â€œslideâ€ a window over the data to reduce time complexity.

## Key Concepts

Window: A contiguous segment of the array/string.

Size: Can be fixed (e.g., 3 elements) or variable (expand/shrink as needed).  

âœ… Patterns in Sliding Window

Sliding Window problems generally follow these patterns:

## 2. Variable-Size Sliding Window

Window size can grow or shrink based on conditions.

Common problems: longest substring without repeating characters, smallest subarray with sum â‰¥ k.

Steps:

Expand window until condition is met.

Shrink window from start until condition fails.

Track the result while moving the window.

## 3. Two-Pointer / Sliding Window Hybrid

Sliding window logic involves two pointers moving independently (start/end).

## TRICK TO REMEMBER 
IF QUESTION SAYS -- find maximum length -- (maxi = max(maxi,r-l+1)
IF QUESTION SAYS -- find all subarrays -- (maxi+=r-l+1)

##### PROBLEMS
## VARIABLE SIZE WINDOW 
### 3. Longest Substring Without Repeating Characters
**Problem:** Given a string `s`, find the length of the longest substring without duplicate characters.  

**Examples:**  

**Example 1:**  
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", length = 3.
## CODE 
from collections import defaultdict

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ad = defaultdict(int)
        left = 0
        maxi = 0
        for r in range(len(s)):
            ad[s[r]] += 1
            while ad[s[r]] == 2:
                ad[s[left]] -= 1
                if ad[s[left]] == 0:
                    del ad[s[left]]
                left += 1
            maxi = max(maxi, r - left + 1)
        return maxi

Common problems: subarrays with at most k distinct elements, permutations, anagrams.

# 209: Minimum Size Subarray Sum

**Problem Statement:**  
Given an array of positive integers `nums` and a positive integer `target`, find the minimal length of a contiguous subarray of which the sum â‰¥ target. Return 0 if no such subarray exists.
Example 1:

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.

## CODE 
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        l = c = t = 0 
        ma = float('inf')
        for r in range(len(nums)):
            t+=nums[r]
            while t >= target:
                ma = min(ma,r-l+1)
                t-=nums[l]
                l+=1
        if ma == float('inf'):
            return 0
        return ma

## 424. Longest Repeating Character Replacement
**Problem:** You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.  

Return the length of the longest substring containing the same letter after performing the operations.  

**Examples:**  

**Example 1:**  
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.

from collections import defaultdict

class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        count = defaultdict(int)  # stores frequency of letters in current window
        l = 0                      # left pointer of the window
        max_count = 0              # max frequency of a single char in window
        res = 0                    # result: max window length

        for r in range(len(s)):    # r is the right pointer
            count[s[r]] += 1
            max_count = max(max_count, count[s[r]])

            # shrink window if more than k replacements needed
            if (r - l + 1) - max_count > k:
                count[s[l]] -= 1
                if count[s[l]] == 0:
                    del count[s[l]]
                l += 1

            res = max(res, r - l + 1)

        return res
##NOTE 
WHEN WE RE DEALING WITH MULTIPLICATION SUMS IN  SLIDING WINDOW VARIABLE SUMS AND WE NEED TO REMOVE LEFT THE NSIMPLY TOTAL // LEFT NOT LIKE TOTAL - LEFT 

### 713. Subarray Product Less Than K
**Problem:** Given an array of integers `nums` and an integer `k`, return the number of contiguous subarrays where the **product** of all the elements in the subarray is **strictly less than k**.  

**Examples:**  

**Example 1:**  
 Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays are:
[10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]
Note: [10,5,2] is not included as 1052 = 100 â‰¥ k

class Solution:
    def numSubarrayProductLessThanK(self, nums: list[int], k: int) -> int:
        if k <= 1:  # No product can be less than 1
            return 0

        prod = 1
        l = 0
        count = 0

        for r in range(len(nums)):
            prod *= nums[r]
            while prod >= k:
                prod //= nums[l]
                l += 1
            count += r - l + 1  # Number of subarrays ending at r

        return count

# 1208. Get Equal Substrings Within Budget

## Problem Description

You are given two strings `s` and `t` of the same length and an integer `maxCost`.

You want to change `s` to `t`. Changing the i-th character of `s` to the i-th character of `t` costs `|s[i] - t[i]|` (absolute difference of ASCII values).

Return the maximum length of a substring of `s` that can be changed to the same as the corresponding substring of `t` with a cost less than or equal to `maxCost`. If no substring can be changed, return 0.

---

## Examples

**Example 1:**
Input: s = "abcd", t = "bcdf", maxCost = 3
Output: 3
Explanation: "abc" of s can change to "bcd". That costs 3. 

class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        left = maxc = total_cost = 0
        for right in range(len(s)):
            total_cost += abs(ord(s[right]) - ord(t[right]))
            while total_cost > maxCost:
                total_cost -= abs(ord(s[left]) - ord(t[left]))
                left += 1
            maxc = max(maxc, right - left + 1)
        return maxc

# Example usage
if __name__ == "__main__":
    sol = Solution()
    print(sol.equalSubstring("abcd", "bcdf", 3))  
    print(sol.equalSubstring("abcd", "cdef", 3))  
    print(sol.equalSubstring("abcd", "acde", 0))  

##  1493. Longest Subarray of 1's After Deleting One Element
 
## Problem Description

Given a binary array `nums`, you should delete **one element** from it.  

Return the size of the **longest non-empty subarray** containing only 1's in the resulting array. Return 0 if there is no such subarray.

---

## Examples

**Example 1:**
Input: nums = [1,1,0,1]
Output: 3
Explanation: Delete the 0 at position 2. The resulting array [1,1,1] has length 3.
# CODE 
from typing import List

class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        left = 0
        zero_count = 0
        max_len = 0
        n = len(nums)
        
        for right in range(n):
            if nums[right] == 0:
                zero_count += 1
            
            while zero_count > 1:
                if nums[left] == 0:
                    zero_count -= 1
                left += 1
            
            # Subtract 1 because we must delete one element
            max_len = max(max_len, right - left)
        
        return max_len

# Example usage
if __name__ == "__main__":
    sol = Solution()
    print(sol.longestSubarray([1,1,0,1]))             
    print(sol.longestSubarray([0,1,1,1,0,1,1,0,1]))    
    print(sol.longestSubarray([1,1,1]))               

# 1695. Maximum Erasure Value

## Problem Description

You are given an array of positive integers `nums` and want to **erase a subarray containing unique elements**.  

The score you get by erasing the subarray is equal to the sum of its elements.  

Return the **maximum score** you can get by erasing exactly one subarray.

An array `b` is called a subarray of `a` if it forms a contiguous subsequence of `a`, i.e., it is equal to `a[l], a[l+1], ..., a[r]` for some indices `(l,r)`.

---

## Examples

**Example 1:**

Input: nums = [4,2,4,5,6]
Output: 17
Explanation: The optimal subarray is [2,4,5,6]. 
## CODE 
from typing import List
from collections import defaultdict

class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        count = defaultdict(int)
        total = 0
        left = 0
        max_sum = 0

        for right in range(len(nums)):
            total += nums[right]
            count[nums[right]] += 1

            while count[nums[right]] > 1:
                count[nums[left]] -= 1
                total -= nums[left]
                if count[nums[left]] == 0:
                    del count[nums[left]]
                left += 1

            max_sum = max(max_sum, total)

        return max_sum

# Example usage
if __name__ == "__main__":
    sol = Solution()
    print(sol.maximumUniqueSubarray([4,2,4,5,6]))          # Output: 17
    print(sol.maximumUniqueSubarray([5,2,1,2,5,2,1,2,5]))  # Output: 8

## ANOTHER PATTERN THAT IS ALSO VARIABLE SIZE BUT USING FUNCTIONS
WHY WE USE THIS PATTERN -- ðŸ”‘ Rule

We use two functions (atMost(goal) and atMost(goal-1)) in situations where:

We want the count of subarrays with sum exactly equal to goal.

Itâ€™s easier to count â€œsum â‰¤ Xâ€ using a sliding window.

Numbers are non-negative (so sliding window works).

ðŸ›  Why goal and goal-1

atMost(goal) â†’ counts subarrays with sum â‰¤ goal
(this includes subarrays with sum = 0, 1, 2 â€¦ up to goal)

atMost(goal-1) â†’ counts subarrays with sum â‰¤ goal-1
(this includes subarrays with sum = 0, 1 â€¦ up to goal-1, but not goal)

ðŸ‘‰ Subtracting removes everything less than goal, leaving only those with sum = goal:

exactlyÂ goal
=
atMost(goal)
âˆ’
atMost(goal-1)
exactlyÂ goal=atMost(goal)âˆ’atMost(goal-1)

## LeetCode 930 â€” Binary Subarrays With Sum

Problem:
Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum equal to goal.
Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are bolded and underlined below:
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
## CODE 
class Solution:
    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
        def ak(goal):
            if goal < 0:
                return 0
            l = a = maxi = 0
            for r in range(len(nums)):
                a+=nums[r]
                while a > goal:
                    a= a -nums[l]
                    l+=1
                maxi += r - l + 1 
            return maxi
        return ak(goal) - ak(goal - 1)

## LeetCode 992 â€” Subarrays with K Different Integers

Problem:
Given an integer array nums and an integer k, return the number of good subarrays of nums.

A good subarray contains exactly k different integers.

A subarray is contiguous.
 Example 1:
nums = [1,2,1,2,3]
k = 2


Subarrays with exactly 2 distinct integers:

[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]


Output: 7 âœ…

## CODE 
class Solution:
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        def am(k):
            l = res = 0
            a = defaultdict(int)
            for r in range(len(nums)):
                a[nums[r]]+=1
                while len(a) > k:
                    a[nums[l]]-=1
                    if a[nums[l]] == 0:
                        del a[nums[l]]
                    l+=1
                res += (r-l)+1
            return res
        return am(k) - am(k-1)

LeetCode 1248 â€” Count Number of Nice Subarrays

Problem:
Given an integer array nums and an integer k, a nice subarray is a contiguous subarray with exactly k odd numbers.

Return the number of nice subarrays.
Example 1:
nums = [1,1,2,1,1]
k = 3


Subarrays with exactly 3 odd numbers: [1,1,2,1] and [1,2,1,1]

Output: 2 âœ…
## CODE 

from typing import List

class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        def atMost(k: int) -> int:
            # Transform nums into binary array: 1 for odd, 0 for even
            c = [1 if num % 2 else 0 for num in nums]
            l = res = sumi = 0
            for r in range(len(c)):
                sumi += c[r]
                while sumi > k:
                    sumi -= c[l]
                    l += 1
                res += (r - l + 1)  # subarrays ending at r with â‰¤ k odd numbers
            return res
        
        return atMost(k) - atMost(k-1)

## HERE WE USE 
IF K < 0:
   RETURN 0 SOME TIMES FOR THSI TYPE OF DUNCTION SUMS AND WE NOT USE FOR SOME SUMS 

WHEN TO NOT USE:
IF INPUT SAYS K IS COMPULSARY STARTS WITH 1 
WHEN TO USE:
IF INPUT SAYS K IS COMPULSARY STARTS WITH 0 


                
            
        


        


        






