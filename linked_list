## Linked List:

A linked list is a way to store a sequence of elements (like numbers) one after another, but unlike arrays, they are not stored in continuous memory.

Each element in a linked list is called a node, and each node has:

Value (val) → the data it holds.

Pointer (next) → a reference to the next node in the list.

## Node in Python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val    # stores value
        self.next = next  # points to next node


head = ListNode(1) → creates first node with value 1.

head.next = ListNode(2) → second node linked to first.

##PATTERNS 
4️⃣ Two Pointers / Slow-Fast Pattern

Use two pointers to solve problems efficiently.

Examples:

Detect cycle (Floyd’s algorithm)

Find middle node

Check palindrome

slow = fast = head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next

# 876. Middle of the Linked List

## Problem
Given the head of a singly linked list, return the middle node of the linked list. 
If there are two middle nodes, return the second middle node.

### Example 1:
Input: head = [1,2,3,4,5]  
Output: [3,4,5]  
Explanation: The middle node of the list is node 3.

##CODE 
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next 
            fast = fast.next.next
        return slow 
## PROBLEM 
# 2095. Delete the Middle Node of a Linked List

## Problem
Given the head of a linked list, delete the middle node and return the head of the modified linked list.  

The middle node of a linked list of size n is the ⌊n / 2⌋th node (0-based indexing).  

### Examples

**Example 1:**  
Input: head = [1,3,4,7,1,2,6]  
Output: [1,3,4,1,2,6]  
##CODE 
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = head
        fast = head
        prev = None
        if fast.next == None:
            return None
        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next
        prev.next = slow.next
        return head
##LINKED LIST USING HASHING 
  DEF :Use a set or dict to solve problems:
1.Remove duplicates
2.Detect cycle
## TO REMEMBER WHEN WE USE HASHING IN LINKED LIST 
Hashing in linked list is used to store  values not nodes (BOTH FOR HASH SET AND HASH TABLE) ONLY STORE VALUES 
##CORRECT ONE 
while b:
            curr = b.next
            hasi[b.val]+=1
            b = curr
        return hasi
##WRONG ONE 
while b:
            curr = b.next
            hasi[b]+=1
            b = curr
        return hasi ## IT WILL GIVE ERRORS BECAUSE WE ARE STORING NODES 
## PROBLEM 
# 82. Remove Duplicates from Sorted List II

## Problem
Given the head of a sorted linked list, delete **all nodes that have duplicate numbers**, leaving only distinct numbers from the original list. Return the linked list **sorted** as well.

### Examples

**Example 1:**  
Input: head = [1,2,3,3,4,4,5]  
Output: [1,2,5]  
 ## CODE 
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def deleteDuplicates(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        a = ListNode(0)
        current = a 
        hasi = defaultdict(int)
        b = head 
        while b:
            curr = b.next
            hasi[b.val]+=1
            b = curr
        l = head 
        while l:
            m = l.next 
            if hasi[l.val] < 2:
                current.next = ListNode(l.val)
                current  = current.next
            l = m 
        return a.next
##LINKED LIST USING MERGE SORT 
1️⃣ Idea

1.Find the middle of the list (use slow and fast pointer).

2.Split the list into two halves.

3.Recursively sort left and right halves.

4.Merge the two sorted halves.

##CODE 
# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution(object):
    def sortList(self, head):
        if not head or not head.next:
            return head 
        mid = self.mid1(head)
        left = self.sortList(head)
        right = self.sortList(mid)
        return self.mer(left,right)
    def mid1(self,head):
        slow = head
        fast = head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        mid = slow.next
        slow.next = None 
        return mid 
    def mer(self,left,right):
        a = ListNode(0)
        cur = a 
        while left and right:
            if left.val <= right.val:
                cur.next = left
                cur = cur.next 
                left = left.next 
            else:
                cur.next = right
                cur = cur.next 
                right = right.next 
        if left:
            cur.next = left 
        if right:
            cur.next = right 
        return a.next
MY DOUBTS = TO FIND MID THERE IS ANOTHER CODE LIKE SLOW = HEAD FAST IS ALSO HEAD ... BUT IN ABOVE MID CODE WE WROTE SLOW = HEAD FAST = HEAD.NEXT 
            
1.Y IT IS NOT WORK WHEN WE ARE WRITING SLOW = HEAD AND FAST = HEAD ..Works for most cases, but sometimes with 2 nodes, the split might result in BALANCE
3️⃣ Why balance matters

Merge sort recursively splits the list in half.

If the left half is much bigger than the right, the recursion can never reach base case properly, causing infinite recursion.

Starting fast = head.next ensures the left and right halves are balanced, even for even-length lists.

Input: head = 1 → 2

Dry-run:

slow = 1, fast = 1

Loop: slow → 2, fast → None → exit

mid = slow.next = None ✅ Problem!

head still = 1 → 2

Left recursion: sortList(head) → 1 → 2 again → infinite recursion

Reason: slow moves too far; left half is not reduced correctly. ## SO IT IS WRONG So we must use slow = head , fast = head.next While dealing with sorts.. 

##ANOTHER DOUBT 
mer(self,left,right): IN THIS FUNTION   while left and right:
            if left.val <= right.val:
                cur.next = left
                cur = cur.next 
                left = left.next  USE LIKE THIS NOT LIKE 
                                       if left.val <= right.val:
                                           cur.next = ListNode(left.val)
                                           cur = cur.next 
                                           left = left.next
                BECAUSE 🔹 Why this may cause issues

                        2.In some LeetCode problems (like Sort Linked List), the problem expects you to return nodes from the original list, not new nodes.

                        3.Using ListNode(left.val) creates brand-new nodes, which can cause TypeError or fail hidden tests.
##PROBLEM 92 
# LeetCode Problem 92: Reverse Linked List II
# Medium
# Given the head of a singly linked list and two integers left and right
# where left <= right, reverse the nodes of the list from position left to position right,
# and return the reversed list.

# Example 1:
# Input: head = [1,2,3,4,5], left = 2, right = 4
# Output: [1,4,3,2,5]

# Example 2:
# Input: head = [5], left = 1, right = 1
# Output: [5]

# Constraints:
# - The number of nodes in the list is n.
# - 1 <= n <= 500
# - -500 <= Node.val <= 500
# - 1 <= left <= right <= n

# Follow up: Can you do it in one pass?

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution(object):
    def reverseBetween(self, head, left, right):
        """
        Reverse a sublist of a singly linked list from position 'left' to 'right'.

        :param head: head of the linked list
        :param left: start position of reversal (1-based index)
        :param right: end position of reversal (1-based index)
        :return: head of the updated linked list
        """

        # Step 0: Create a dummy node to simplify edge cases
        a = ListNode(0)
        a.next = head
        b = a
        prev = None

        # Step 1: Move `b` to the node just before 'left'
        for i in range(left-1):
            b = b.next

        # Step 2: `curr` points to the first node in the sublist to reverse
        curr = b.next

        # Step 3: Reverse the sublist from left to right
        for i in range(right-left+1):
            c = curr.next      # temporarily store the next node
            curr.next = prev   # reverse the link
            prev = curr        # move prev forward
            curr = c           # move curr forward

        # Step 4: Connect the tail of reversed sublist to the remaining list
        b.next.next = curr

        # Step 5: Connect the node before sublist to the new head of reversed sublist
        b.next = prev

        # Step 6: Return the new head (skip dummy node)
        return a.next

##DOUBTS 
INPUT -- 1->2->3->4->5 
  # ----------------------------
# Key Trick in Reverse Linked List II (step-by-step)
# ----------------------------

# Input: 1 -> 2 -> 3 -> 4 -> 5
# Reverse from left=2 to right=4
##AFTER ALL ITERATIONS 
# Step 0: After reversing the sublist (2->3->4 becomes 4->3->2)
# prev -> 4 -> 3 -> 2
# curr -> 5
# b -> 1
# b.next -> 2 (tail of reversed sublist)

# Step 1: Connect tail of reversed sublist to the rest of the list
b.next.next = curr
# 2.next = 5
# Now sublist looks like: prev = 4 -> 3 -> 2 -> 5
but my doubt is 2 is at starting by and we not assgin prev how it changes the prev 
## but 1 points to 2 ... 2 is at prev so 2 .next = 5 we got prev = 4->3->2> 5 

# Step 2: Connect node before sublist to head of reversed sublist
b = 1 ->2 
prev =  4->3->2> 5 
b.next = prev
# 1.next = 4
# Now the full list: 1 -> 4 -> 3 -> 2 -> 5
2 in b overrides but that 2 already present in prev so no loss 

# Step 3: Return updated head
return a.next
# Skip dummy node 'a' to get real head: 1 -> 4 -> 3 -> 2 -> 5


                                         
            
            
        
