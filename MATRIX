# Matrix Definition

A **matrix** is a rectangular arrangement of numbers in rows and columns.

Example:
[
[1, 2, 3],     
[4, 5, 6]
]

This matrix has:
- 2 rows ‚Üí [1,2,3], [4,5,6]
- 3 columns ‚Üí [1,4], [2,5], [3,6]

### Key Terms: 
- **Row:** A horizontal line of elements
- **Column:** A vertical line of elements
- **Element:** A single value in the matrix

## How to scan matrix 
n = int(input())
mat = []
for i in range(n):
        mat.append(list(map(int, input().split())))

## This code creates a matrix filled with zeros
rows = 3
cols = 3
matrix = [[0] * cols for i in range(rows)]
Result: The matrix is strictly [[0, 0, 0], [0, 0, 0], [0, 0, 0]].

## ANOTHER TYPE TO CREATE MATRIX The Input Method (Dynamic Data)
This code creates a matrix based on user input. The values are determined by what is typed during execution.

n = int(input("Enter number of rows: "))
matrix = []

for i in range(n):
    row = list(map(int, input(f"Enter row {i} elements separated by space: ").split()))
    matrix.append(row)

StepUser TypesWhat input().split() seesWhat mat looks like after appendLoop 11 2 3['1', '2', '3'][[1, 2, 3]]
Loop2  4 5 6['4', '5', '6'][[1, 2, 3], [4, 5, 6]]Loop 3  7 8 9['7', '8', '9'][[1, 2, 3], [4, 5, 6], [7, 8, 9]]
Matrix can be written as `m x n` (m rows and n columns).
Example: The above matrix is `2 x 3`.

üíª 2Ô∏è‚É£ 2_sum_of_all_elements.py 
## CODE 
# Program to find total sum of all elements in a matrix
mat = [
    [1, 2, 3],
    [4, 5, 6]
]
total = 0
for i in range(len(mat)):
    for j in range(len(mat[i])):
        total += mat[i][j]

print("Total Sum =", total)
# Output: Total Sum = 21

# üßÆ LeetCode 1572: Matrix Diagonal Sum

**Level:** Easy  
**Topics:** Matrix, Array  
**Acceptance Rate:** 83.9%

---

## üìù Problem Statement

Given a square matrix `mat`, return the sum of the matrix diagonals.

Only include the sum of all the elements on the **primary diagonal** and all the elements on the **secondary diagonal** that are **not part of the primary diagonal**.

---

### üîπ Example 1

**Input:**
 mat = [[1,2,3],
[4,5,6],
[7,8,9]]


**Explanation:**  
Diagonals sum: 1 + 5 + 9 + 3 + 7 = **25**  
Notice that element `mat[1][1] = 5` is counted only once.
##CODE 

---

## üíª Code Solution (Python)
```python
class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        c = 0
        for i in range(len(mat)):
            c += mat[i][i]
            c += mat[i][len(mat) - (i + 1)]
        if len(mat) % 2 == 0:
            return c
        a = len(mat) // 2
        return c - mat[a][a]

üíª 3Ô∏è‚É£ 3_row_and_column_sum.py

# Program to find row and column sums of a matrix

mat = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

rows = len(mat)
cols = len(mat[0])

# Row sums
row_sum = []
for i in range(rows):
    s = 0
    for j in range(cols):
        s += mat[i][j]
    row_sum.append(s)

# Column sums
col_sum = []
for j in range(cols):
    s = 0
    for i in range(rows):
        s += mat[i][j]
    col_sum.append(s)

print("Row sums =", row_sum)
print("Column sums =", col_sum)
# Output:
# Row sums = [6, 15, 24]
# Column sums = [12, 15, 18]

## THE ABOVE CODE USING ZIP  WITH BETTER COMPLEXITY 
# Program to find row and column sums of a matrix using zip(*mat)

mat = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Row sums
row_sum = [sum(row) for row in mat]

# Column sums using zip(*mat)
col_sum = [sum(col) for col in zip(*mat)]

print("Row sums =", row_sum)
print("Column sums =", col_sum)

# Output:
# Row sums = [6, 15, 24]
# Column sums = [12, 15, 18]

zip(*mat) ‚Üí converts rows into columns:

(1, 4, 7)
(2, 5, 8)
(3, 6, 9)

## MORE DETAILED EXPLANATION 
Perfect üëç ‚Äî you want to see how *mat actually unpacks rows.
Let‚Äôs make that super clear with a small example üëá
mat = [
    [1, 2, 3],
    [4, 5, 6]
]

üí° What *mat does

If you just print it:

print(*mat)


Output:

[1, 2, 3] [4, 5, 6]
 
‚öôÔ∏è Inside zip(*mat)

When you write:

zip(*mat)


It‚Äôs the same as:

zip([1, 2, 3], [4, 5, 6])

How zip() works

zip() pairs elements position-by-position (same index) from each list.

So now zip can join them like this:

(1, 4)
(2, 5)
(3, 6)


That‚Äôs how columns are formed.

‚úÖ In short:

mat ‚Üí [[1,2,3], [4,5,6]] (one list with 2 rows)

*mat ‚Üí [1,2,3] [4,5,6] (two separate lists)

zip(*mat) ‚Üí [(1,4), (2,5), (3,6)] (transposed / column-wise view)


566. Reshape the Matrix
üìå Problem Statement

You are given:

A matrix mat of size m √ó n

Two integers r and c

Your task is to reshape the matrix into a new matrix of size r √ó c while keeping the same row-wise order of elements.

üëâ If reshaping is not possible, return the original matrix.

üîç Key Observation

Total elements in original matrix = m √ó n

Total elements in new matrix = r √ó c

‚úÖ Reshape is possible ONLY IF
m √ó n == r √ó c
Otherwise:

Return original matrix

üß† Core Idea (How to Think)

Traverse the original matrix row by row

Store elements into the new matrix in the same order

Use a single counter to map elements correctly

Why counter works?

Because:

count // c ‚Üí row index in new matrix

count % c ‚Üí column index in new matrix

‚úèÔ∏è Mapping Logic (Important)

Original matrix is read like:

1 ‚Üí 2 ‚Üí 3 ‚Üí 4


New matrix is filled like:

result[count // c][count % c]


This keeps row-traversing order intact.

üß™ Example 1
Input
mat = [[1,2],
       [3,4]]
r = 1, c = 4

Output
[[1, 2, 3, 4]]

Explanation

Original elements = 4

New matrix capacity = 4

Reshape possible ‚úÖ

üß™ Example 2
Input
mat = [[1,2],
       [3,4]]
r = 2, c = 4

Output
[[1,2],
 [3,4]]

Explanation

Original elements = 4

New matrix capacity = 8

Reshape NOT possible ‚ùå

Return original matrix

##CODE 
class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])

        # Check if reshape is possible
        if m * n != r * c:
            return mat

        # Create new matrix
        result = [[0] * c for _ in range(r)]

        count = 0
        for i in range(m):
            for j in range(n):
                result[count // c][count % c] = mat[i][j]
                count += 1

        return result

‚è±Ô∏è Complexity Analysis
Time Complexity: O(m √ó n)
Space Complexity: O(r √ó c)

When we got problwms like reshpe we want to use this divivsion operators like // and % so that we can get 
##DOUBTS I GOT LOT OF THIS SUMS Y WE ARE USING result[count // c][count % c] = mat[i][j] HOW YOU GET THIS IDEA
count//c is nothing but üéØ Final answer in ONE sentence
We use count // c because integer division tells how many complete groups of c elements are filled, and each group corresponds to one row in the reshaped matrix.
Row = how many full rows of c items are completed ‚Üí count // c ** When count crosses a multiple of c, count // c tells which row we are in (1st row, 2nd row, etc.).

##Y [count % c]
Now I‚Äôll explain count % c in the same simple, slow way.

Think again of placing elements one by one

Each row can hold c elements

count = number of elements already placed

You already know:

count // c ‚Üí which row

Now the question is:

Inside that row, which position (column) is this element?

What does % (modulo) mean?

% means:

remainder after division

Why remainder gives column?

When you divide count by c:

The quotient (count // c) tells how many full rows are done

The remainder (count % c) tells how many elements are already placed in the current row

That number is exactly the column index.

Example with c = 4
count	count % 4	meaning
0	0	1st column
1	1	2nd column
2	2	3rd column
3	3	4th column
4	0	new row, 1st column
5	1	2nd column
Simple way to remember

count % c tells the position inside the row.

Or in words:

After filling c elements, column starts again from 0.

Final clear meaning

We use count % c because it tells how many elements are already placed in the current row, which directly gives the column index.

That‚Äôs all.
