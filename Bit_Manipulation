ğŸ”¹ What is Bit Manipulation?

Bit manipulation means working with numbers in binary (0 and 1) using special operators.
 
ğŸ‘‰ Computer does NOT understand 10, 20, 50 
ğŸ‘‰ Computer understands only 0 and 1
  
So bit manipulation =
playing with 0s and 1s to solve problems faster
 
ğŸ§  The 5 Core Bitwise Magic Tricks

These 5 patterns solve ~90% of bit manipulation problems. 

1ï¸âƒ£ n & (n - 1) â†’ Removes the Rightmost Set Bit
ğŸ’¡ What it does:

It removes the lowest (rightmost) 1 bit from n.
 
Example:
n = 12 â†’ 1100
n-1 = 11 â†’ 1011
----------------
n & (n-1) = 1000


The rightmost 1 disappeared.

âœ… Uses:

âœ” Check power of 2:

if n > 0 and (n & (n - 1)) == 0:


âœ” Count set bits:

count = 0
while n:
    n = n & (n - 1)
    count += 1

## SOME TIMES WE WILL USE 
(n & (n-1)) ^ n
ğŸ§  Simple Understanding
Step 1: Remove rightmost 1
Step 2: Compare with original using XOR
Step 3: You get only that removed bit

âœ… Example 2
n = 12
Binary = 1100

n-1 = 1011

n & (n-1)
1100
1011
-----
1000

Now XOR:
1000
1100
-----
0100

Result = 4
Rightmost set bit of 12 = 4 âœ…

âš¡ Important
This is used in:

 
Finding lowest set bit


Binary Indexed Tree


Bit manipulation problems



If you want, I can also show why n & -n gives same result ğŸ‘€
That trick is even more powerful ğŸš€


Time complexity = O(number of set bits)

2ï¸âƒ£ n & -n â†’ Isolates the Rightmost Set Bit
ğŸ’¡ What it does:

It extracts only the lowest 1 bit.

Example:
n = 12 â†’ 1100
-n = twoâ€™s complement
n & -n = 0100
HOW IT CAME MEANS 1 1 0 0 
       COMPLEMENT 0 0 1 1 
          ADD 1   0 0 0 1 
          FINAL   0 1 0 0 
It gives only the lowest set bit.

âœ… Uses:

âœ” Find first set bit position
âœ” Used in Fenwick Tree (BIT)
âœ” Used in subset / mask problems

They are very similar, but they do the opposite things. Think of them as two different tools in the same toolbox.

n & -n is a Filter: It keeps ONLY the rightmost 1 and turns everything else to 0.

n & (n - 1) is a Eraser: It keeps everything ELSE and turns ONLY the rightmost 1 to 0

3ï¸âƒ£ x ^ y â†’ Finds Where Bits Differ
ğŸ’¡ What it does:

XOR gives 1 where bits are different.

A	B	A ^ B
0	0	0
1	1	0
0	1	1
1	0	1
âœ… Uses:

âœ” Find single number:

res = 0
for num in nums:
    res ^= num


âœ” Find two unique numbers
âœ” Check if two numbers differ at a bit
âœ” Prefix XOR problems

4ï¸âƒ£ 1 << i â†’ Create a Mask
ğŸ’¡ What it does:

Creates a number with only ith bit set.

Example:

1 << 3  â†’ 1000  (which is 8)

âœ… Uses:

âœ” Check if ith bit is set:

if n & (1 << i):


âœ” Set ith bit:

n |= (1 << i)


âœ” Toggle ith bit:

n ^= (1 << i)


âœ” Clear ith bit:

n &= ~(1 << i)

5ï¸âƒ£ Bonus Trick: Swap Without Temp
a = a ^ b
b = a ^ b
a = a ^ b

## IF WE WANT TO CHANGE 0  0 0 1 TO 1 1 1 0 JUST FLIPPING BITS LIKE 0 TO 1 OTR 1 TO 0
JUST USE XOR 
N ^ 1 
Operation         Binary     Decimal
--------------------------------------
Original (n)       1010       10
Mask               1111       15
--------------------------------------
Result (n ^ Mask)  0101        5


(Not recommended in real code, but common interview trick.)
ğŸ”¹ What is a BIT?

A bit is the smallest unit of data

Bit â†’ 0 or 1


Examples:

5 in binary = 101
8 in binary = 1000

ğŸ”¹ Why learn Bit Manipulation?

Because:

Faster solutions ğŸš€

Used in LeetCode, HackerRank, exams

Used in DSA, OS, networking

ğŸ”¹ Binary Numbers (VERY IMPORTANT)
Decimal	Binary
1	1
2	10
3	11
4	100
5	101
6	110
7	111
8	1000

ğŸ”‘ STEP-1: Ask THIS question to yourself

Am I touching individual bits (0 / 1)?

If âŒ NO â†’ normal math / logic

If âœ… YES â†’ BIT MANIPULATION

In your code:
(t >> i) & 1
(1 << i)
t | (1 << i)


You are checking, shifting, setting individual bits
ğŸ‘‰ So BIT MANIPULATION âœ”

ğŸ”‘ STEP-2: Ask THIS second question

Am I creating a pattern like 0001, 0010, 0100 to target one bit?

If YES â†’ BIT MASKING

In your code:
(1 << i)


Examples:

i = 0 â†’ 0001
i = 1 â†’ 0010
i = 2 â†’ 0100


This pattern is called a MASK because:

it targets one bit

hides others

ğŸ‘‰ So BIT MASKING âœ”

ğŸ” How to IDENTIFY in exams / interviews
See these operators? ğŸš¨
<<   >>   &   |   ^


ğŸ‘‰ Immediately think:

BIT MANIPULATION

See this pattern? ğŸš¨
1 << i
n & (1 << i)
n | (1 << i)


ğŸ‘‰ Immediately think:

BIT MASKING

ğŸ§  Very simple real-life analogy
Bit manipulation = working with switches
[1][0][1][0]


You are turning individual switches ON/OFF

Bit masking = using tape to touch only one switch
Mask â†’ 0001

âœ… One-line exam answer (remember this)

When a problem uses bitwise operators to access or modify individual bits, it is bit manipulation.
If it uses patterns like 1 << i to target a specific bit, it is bit masking.

ğŸ‘‰ Every number = sum of powers of 2

Example:

5 = 4 + 1
  = 100 + 001
  = 101

ğŸ”¹ Bitwise Operators (MAIN THING)
1ï¸âƒ£ AND (&)

ğŸ‘‰ Both bits must be 1

1 & 1 = 1
1 & 0 = 0
0 & 0 = 0


Example:

5 & 3
5 = 101
3 = 011
---------
    001 = 1

##IT IS USED TO CHECK EVEN OR ODD 
3ï¸âƒ£ Example (VERY CLEAR)
Example 1: EVEN number
6 & 1


Binary:

6 = 110
1 = 001


AND:
 
110
001
---
000  â†’ 0


âœ… Result = 0 â†’ EVEN

n = 7

if n & 1:
    print("Odd")
else:
    print("Even")


2ï¸âƒ£ OR (|)

ğŸ‘‰ If any one is 1, result is 1

1 | 0 = 1
0 | 0 = 0


Example:

5 | 3
101
011
---
111 = 7

##WHEN IT IS USED 
USED TO CHECK AT LEAST THERE IS 1 
âœ… Use Case 1: TURN ON A BIT (MOST IMPORTANT)

OR is used to set / turn ON a bit.

Example:

x = 4      # 100
x = x | 1  # turn ON last bit


Binary:

100 | 001 = 101


Result:

5


ğŸ‘‰ Used in bit masking
3ï¸âƒ£ XOR (^) â­ IMPORTANT

ğŸ‘‰ Same â†’ 0
ğŸ‘‰ Different â†’ 1

1 ^ 1 = 0
1 ^ 0 = 1


Example:

5 ^ 3
101
011
---
110 = 6 

2ï¸âƒ£ Important Properties (VERY IMPORTANT â­)
a ^ a = 0        â†’ same number cancels
a ^ 0 = a        â†’ XOR with 0 gives same number
a ^ b ^ a = b    â†’ order does not matter

3ï¸âƒ£ Why XOR Removes Duplicates?

Duplicate numbers appear twice

XOR of same numbers becomes 0

So duplicates cancel each other

Only the single number remains

Example:

[2, 3, 2]
â†’ (2 ^ 2) ^ 3
â†’ 0 ^ 3
â†’ 3

##WHEN IT IS NOT USED 
IF THERE ARE MORE THAN ONE SINGLE ELEMENT IN THE ARRAY COR IS NOT USE FULL

5ï¸âƒ£ Python Code (Exam Ready)
ans = 0
for x in nums:
    ans ^= x
print(ans)

ğŸ”¹ SHIFT OPERATORS â€” SHORT NOTES

There are 2 types:
1ï¸âƒ£ Left Shift <<
2ï¸âƒ£ Right Shift >>

1ï¸âƒ£ LEFT SHIFT (<<)
ğŸ‘‰ What it does

Shifts bits to the LEFT

Adds 0 at the right end

Multiplies the number by 2

ğŸ”¹ Rule (IMPORTANT â­)
n << k = n Ã— (2^k)

ğŸ”¹ Example 1
5 << 1

here  n = 5 , k= 1 
2 * 1 = 2 
now 5 * 2 = 10

Binary:

5 = 101
â†’ 1010


Decimal:

1010 = 10


âœ… Result:

5 << 1 = 10

ğŸ”¹ Example 2
6 << 2


Binary:

6 = 110
â†’ 11000


Decimal:

11000 = 24


âœ… Result:

6 << 2 = 24

ğŸ”¹ When to use <<

Fast multiplication

n * 2 â†’ n << 1

n * 4 â†’ n << 2

ğŸ”¹ WHERE TO USE LEFT SHIFT (<<)
1ï¸âƒ£ When multiplying by power of 2

Use left shift when multiplication is:

Ã—2, Ã—4, Ã—8, Ã—16, ...

Example:
n = 5
n << 1   # 5 Ã— 2 = 10
n << 2   # 5 Ã— 4 = 20
n << 3   # 5 Ã— 8 = 40


ğŸ‘‰ Used when * is not allowed.

## DOUBT IN LEFT SHIFT MEAN WHILE THIS IS ALSO DOUBT FOR RIGHT SHIFT THAT IS 
LETS SUPPOSE N = 6 
IF I DO N >> 1 IT WILL WORK IN THE SAME WAY I DONE SOME THING DIFFERENT THAT 
BINARY OF 6  I DONE BIN(6) [2:]IS '1 1 0' I DONE '1 1 0' >> 1 THEN IT WILL NOT WORK BOTH ARE SAME  EVEN IF WE DO LIKE 6 ITS TREATES AS BINARY BUT WE CANT INITIALISE BINARY DIRECTLY  
BECAUSE THESE BIT WISE OPERATORS >> , << WORKS ONLY WITH INTEGERS NOT LIKE THES STRINGS('110') BUT 110 IT WILL WORK  BEACUSE IT IS INTEGET 
Case 1ï¸âƒ£ '110' >> 1 âŒ
'110' >> 1

IF WE ARE HAVING LIKE '110' THEN WE NEED TO CONVERT INTO INT THEN  
s = '1100'
n = int(s, 2)
print(n)

OUTPUT = 12


âŒ Will NOT work
s = 1100 
n = int(s,2)
print(n) 
Reason:

'110' â†’ string

Bitwise operators (>>, <<, &, |, ^)
ğŸ‘‰ work ONLY on integers

Python error:

TypeError: unsupported operand type(s) for >>: 'str' and 'int'

Case 2ï¸âƒ£ 110 >> 1 âœ… (BUT careful!)
110 >> 1


âœ”ï¸ This WILL work

Output:

55

Why 55?

110 here is a decimal number, NOT binary

Decimal 110 in binary is:

110 (decimal) = 1101110 (binary)


Right shift by 1:

1101110  â†’  110111


110111 (binary) = 55

ğŸ‘‰ Python does NOT think 110 is binary
ğŸ‘‰ Python thinks 110 is decimal

ğŸ”¹ RIGHT SHIFT (>>)
1ï¸âƒ£ What is Right Shift?

ğŸ‘‰ Moves binary bits to the RIGHT
ğŸ‘‰ Removes the last bit
ğŸ‘‰ Divides the number by 2 (integer division)

2ï¸âƒ£ Example (VERY CLEAR)
Example 1
10 >> 1


Binary:

10 = 1010


Right shift by 1:

1010 â†’ 101


Decimal:

101 = 5


âœ… Result:

10 >> 1 = 5

3ï¸âƒ£ Where to Use Right Shift?
âœ… Use Case 1: Divide by Power of 2

When question says:

Divide without using /

n >> 1  â†’  n Ã· 2
n >> 2  â†’  n Ã· 4
n >> 3  â†’  n Ã· 8

##SMLL TRICK THERE IS NUMBER 
LIKE N = 11 WE WANT LIKE IN BINARY FORMAT 
then use (bin(n)[2:])
// here it works only for 26 bits 

## FOR 32 BITS 
    r = bin(n)[2:].zfill(32) 

## n & 1: This looks only at the very last bit. If the last bit is 1, 
the result is 1. If it's 0, the result is 0.

## PROBLEM 
Set the rightmost bit



3

Problem Statement: Given a positive integer n, set the rightmost unset (0) bit of its binary representation to 1 and return the resulting integer.
If all bits are already set, return the number as it is.

Examples
Example 1:
Input:
 n = 10 (binary: 1010)  
Output:
 11 (binary: 1011)  
Explanation:
  The rightmost unset bit is the least significant bit (LSB). Setting it to 1 gives 1011 = 11.

##CODE 
âœ… Code Being Dry-Run
n = 10
bi = bin(n)[2:]
t = n
le = len(bi)

for i in range(le):
    if (t >> i) & 1 == 0:
        t = t | (1 << i)
        break

print(t)

MY DOUBT 
SEE 

Code
Testcase
Testcase
Test Result
260. Single Number III
Medium
Topics
premium lock icon
Companies
Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once
. You can return the answer in any order.

You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

Example 1:

Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.
Example 2:

Input: nums = [-1,0]
Output: [-1,0]
Example 3:

Input: nums = [0,1]
Output: [1,0]
 

Constraints:

2 <= nums.length <= 3 * 104
-231 <= nums[i] <= 231 - 1
Each integer in nums will appear twice, only two integers will appear once.
 
You said:

Many bit positions may be different between the two unique numbers.
But we are taking only ONE bit.
Using that one bit, we split into two groups.
One unique number goes to one group.
The other unique number goes to another group.
Remaining duplicates cancel.
Finally two numbers remain.
Thatâ€™s it. Right?

##code 
from typing import List

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        xor = 0
        
        # Step 1: XOR all numbers
        for n in nums:
            xor ^= n
        
        # Step 2: Get rightmost set bit
        diff = xor & -xor
        
        a = 0
        b = 0
        
        # Step 3: Divide into two groups
        for n in nums:
            if n & diff:
                a ^= n
            else:
                b ^= n
        
        return [a, b]





