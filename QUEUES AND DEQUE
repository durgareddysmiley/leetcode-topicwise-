 ##ðŸŒ€ Queue

A queue is like a line in front of a shop.

It follows FIFO (First In, First Out) â†’ the first element added is the first one to be removed.  

Operations: 

enqueue() â†’ add element at the back

dequeue() â†’ remove element from the front

# ðŸŒ€ Deque (Double-Ended Queue)

A **deque** (pronounced *deck*) is a data structure that allows insertion and deletion from **both ends** â€” **front** and **rear**.

---

## ðŸ”¹ Operations

| Operation | Description |
|------------|--------------|
| `append(x)` | Insert element at the **rear** (addLast) |
| `appendleft(x)` | Insert element at the **front** (addFirst) |
| `pop()` | Remove element from the **rear** (removeLast) |
| `popleft()` | Remove element from the **front** (removeFirst) |

---

## ðŸ”¹ Behavior Modes

### âž¤ Acts like a **Queue (FIFO)**
If you use:
```python
dq.append(x)
dq.popleft()

##PROBLEMS
# ðŸ± LeetCode #1700 â€” Number of Students Unable to Eat Lunch

---

## ðŸ§© Problem Description
The school cafeteria offers **circular** and **square** sandwiches at lunch break, represented by numbers `0` and `1`, respectively.  
All students stand in a queue, and each student either prefers circular (`0`) or square (`1`) sandwiches.

The number of sandwiches in the cafeteria is equal to the number of students.  
The sandwiches are placed in a **stack**, where `sandwiches[0]` is the top of the stack.

At each step:

1. If the student at the front of the queue prefers the sandwich on top of the stack,  
   they take it and leave the queue.  
2. Otherwise, they go to the **end of the queue**.  
3. The process continues until **no student** wants the top sandwich.

Return the **number of students unable to eat**.

---

## ðŸ§® Example 1

### Input
```python
students = [1, 1, 0, 0]
sandwiches = [0, 1, 0, 1]

Output
0

##CODE 
class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        q = deque(range(len(students)))
        i = 0
        c = 0
        attempts= 0
        while q and attempts < len(q):
            a = q.popleft()
            if students[a] != sandwiches[i]:
                q.append(a)
                attempts+=1
                
            else:
                c+=1
                i+=1
                attempts = 0
        return len(students)-c

##PROBLEMS
# ðŸƒ LeetCode #950 â€” Reveal Cards In Increasing Order

---

## ðŸ§© Problem Description
You are given an integer array `deck`.  
Each element represents a unique card with a number written on it.

Initially, all cards are **face down** in a deck.  
You can arrange the cards in any order you want.

You repeatedly perform the following steps **until all cards are revealed**:

1. Take the **top card** of the deck, **reveal it**, and remove it from the deck.  
2. If there are still cards in the deck, move the **next top card** to the **bottom** of the deck.  
3. Repeat until all cards are revealed.

Your task is to **reorder the deck** such that the cards are **revealed in increasing order**.

Return the deck **ordering** that will achieve this.

> The first element in the output represents the top of the deck.

---

## ðŸ§® Example 1

### Input
```python
deck = [17, 13, 11, 2, 3, 5, 7]
Output
[2, 13, 3, 11, 5, 17, 7]
##CODE
from collections import deque
from typing import List

class Solution:
    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:
        deck.sort()  # Sort the deck in increasing order
        a = deque(range(len(deck)))  # Index positions queue
        result = [0] * len(deck)
        for i in range(len(deck)):
            result[a.popleft()] = deck[i]  # Place smallest remaining card
            if a:
                a.append(a.popleft())  # Move next index to bottom
        return result
##PROBLEM
# ðŸŽŸ LeetCode #2073 â€” Time Needed to Buy Tickets

---

## ðŸ§© Problem Description
There are `n` people in a line to buy tickets, where:

- The **0th person** is at the front
- The **(n-1)th person** is at the back

You are given a 0-indexed array `tickets` of length `n`:

- `tickets[i]` = number of tickets the ith person wants to buy.

Each person:

1. Takes **1 second** to buy **1 ticket**.
2. If they need more tickets, they go to the **end of the line**.
3. Leaves the line once they bought all tickets.

Return the **time taken** for the person initially at position `k` to finish buying tickets.

---

## ðŸ§® Example 1

### Input
```python
tickets = [2, 3, 2]
k = 2
Output
6
##CODE 
from collections import deque
from typing import List

class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        q = deque(range(len(tickets)))  # Queue of indices
        time = 0

        while tickets[k] > 0:
            idx = q.popleft()
            tickets[idx] -= 1
            time += 1
            if tickets[idx] > 0:
                q.append(idx)  # Person goes to end if tickets remain

        return time
ROTATE IN DEQUE 
1. What is rotate?

In Python, rotate is a method of the deque (double-ended queue) from the collections module. It shifts elements in the deque left or right by a specified number of steps.
d = deque([1, 2, 3, 4, 5])

d.rotate(2)   # rotate right by 2
print(d)      # Output: deque([4, 5, 1, 2, 3])

d.rotate(-3)  # rotate left by 3
print(d)      # Output: deque([2, 3, 4, 5, 1])

## PROBEM 
# ðŸ”„ LeetCode #1823 â€” Find the Winner of the Circular Game

---

## ðŸ§© Problem Description
There are `n` friends sitting in a **circle**, numbered `1` to `n` clockwise.  

Game rules:

1. Start at friend `1`.
2. Count the next `k` friends clockwise **including the starting friend**. Counting wraps around the circle.
3. The last friend counted **leaves the circle**.
4. Repeat starting from the friend immediately clockwise of the removed friend.
5. The **last remaining friend** is the winner.

Return the number of the winner.

---

## ðŸ§® Example 1

### Input
```python
n = 5
k = 2
Output
3
##CODE 
from collections import deque

def findTheWinner(n, k):
    friends = deque(range(1, n + 1))  # friends numbered 1 to n
    
    while len(friends) > 1:
        friends.rotate(-(k - 1))  # rotate so that the k-th friend comes to the front
        friends.popleft()          # remove the friend who loses

    return friends[0]

# Example usage:
print(findTheWinner(5, 2))  # Output: 3
print(findTheWinner(6, 5))  # Output: 1



